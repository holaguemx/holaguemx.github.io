<!DOCTYPE html>
<html>
<head>
<title>Northeast MX  |  Market Spots - Real Estate & Business</title>

<meta charset="utf-8" />
  
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://www.gstatic.com/charts/loader.js"></script>
<script>google.charts.load('current', {packages:['corechart']});</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/geocodezip/geoxml3@master/polys/geoxml3.js"></script>
<script src="https://unpkg.com/togeojson@0.16.0/dist/togeojson.min.js"></script>
<script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.21.0/services/services-web.min.js" defer></script>
<script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.21.0/plugins/SearchBox/SearchBox-web.js" defer></script>
<link rel="stylesheet" type="text/css" href="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.21.0/plugins/SearchBox/SearchBox.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>


<style>
html, body { height: 100%; margin: 0; padding: 0;overflow: hidden;} #map {height: 100%;width: 100%;position: absolute;top: 0;left: 0;}
#filter-panel { position: fixed; top: -1350px; left: 90px; width: 375px; height: 750px; background: white; border: 10px solid #ff6600; border-radius: 5px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: top 0.5s ease; z-index: 10; display: flex; flex-direction: column; overflow-y: auto; }
#filter-panel.open { top: 10px; }
#filter-header { display: flex; justify-content: center; align-items: center; background: #ff6600; color: white; padding: 15px; font-weight: bolder; position: relative;font-family: 'Segoe UI', sans-serif;}
#filter-content { padding: 10px; overflow-y: auto; flex-grow: 1; -webkit-overflow-scrolling: touch; touch-action: auto; font-family: 'Segoe UI', sans-serif; font-size: medium;}
#filter-header button { background: none; border: none; color: white; font-size: 20px; cursor: pointer; }
.filter-section.franchises { margin-top: 10px;}
#filter-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
.filter-section {margin-bottom: 10px;}
.dropdown summary { background-color: white; padding: 8px 12px; border-radius: 4px; display: flex; justify-content: flex-start; align-items: center; cursor: pointer; font-size: 12px; font-weight: bold; gap: 6px;}
.dropdown summary span.category-label { color: #ff6600;}
.dropdown summary span.subcategory-label {color: #000000;}
.toggle-btn { display: flex; align-items: center; justify-content: space-between; padding: 4px 10px; border: 1px solid #ccc; border-radius: 4px; margin: 5px 0; cursor: pointer; background: white; color: grey; font-size: 12px;}
.toggle-btn.active { background: #ff6600; color: white; }
#toast { position: fixed; top: 12px; left: 50%; transform: translateX(-50%); background-color:#ff6600; color: white; padding: 10px 20px; border-radius: 6px; font-size: 14px; display: none; z-index: 99999; box-shadow: 0 4px 8px rgba(0,0,0,0.2);font-family: 'Segoe UI', sans-serif;}
.popup { position: fixed; top: 65px; background-color: white; border-radius: 10px; padding: 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); font-family: 'Segoe UI', sans-serif; z-index: 9999; width: 600px; height: auto; max-height: 900px; overflow-y: auto; display: none; transition: transform 0.3s ease; }
#popup { left: 20px; width: 650px; border: 2px solid #ff6600;}
#popup.shifted { transform: translateX(600px);}
#popup2 { top: 7%; right: 1%; width: 375px; border: 5px solid #ff6600; border-radius: 5px; transform: translateY(0%); height: auto; max-height: 80%; overflow-y: auto; display: none;}
.popup-header { position: sticky;top: 0;z-index: 10;background-color: #ff6600;color: white;padding: 12px 16px;font-size: 14px;font-weight: bold;display: flex;justify-content: space-between;align-items: center;border-radius: 0 0 0 0;box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
#popup2 .popup-header { background-color: #ff6600; }
.popup-close { cursor: pointer;font-size: 14px;font-weight: bold;color: white;line-height: 1;padding-left: 10px;}
.popup-close:hover { color: #000; }
.popup button { margin-top: 10px; background-color: #ff6600; color: white; border: none; padding: 10px 20px; font-size: 14px; border-radius: 6px; cursor: pointer;}
.popup button:hover { background-color: #ff6600; }
#subcategorychart,  #piechart { width: 100%; height: 200px;}
#franchisechart{ width: 100%; height: 300px;}
.popup-inline-data { margin-bottom: 10px; font-weight: bold;}
.filter-buttons { display: flex; justify-content: space-between; gap: 5px; margin-bottom: 10px;}
.filter-buttons { display: flex; justify-content: center;gap: 10px; margin-bottom: 10px;}
.filter-buttons button { background: #ff6600; color: white; border: none; padding: 6px 10px; font-size: 12px; border-radius: 4px; cursor: pointer; min-width: 90px; text-align: center;}
.filter-buttons button:last-child { background: gray; }
.filter-buttons button:hover { opacity: 0.9; }
.summary-checkbox { margin-left: auto; }
.nse-checkbox-group { display: flex; flex-direction: row; align-items: flex-start; gap: 0px;}
.nse-checkbox-group::-webkit-scrollbar {display: none;}
.nse-checkbox-group label {white-space: nowrap;display: flex;align-items: center;font-size: 12px;font-family: 'Segoe UI', sans-serif;}
.operations-checkbox-group label { font-family: 'Segoe UI', sans-serif; font-size: 12px; color: #333333; margin-bottom: 4px;}
.dropdown summary { padding-left: 0 !important;}
.summary-checkbox { margin: 0 !important;}
.filter-buttons-inline { display: flex; gap: 5px;}
.filter-buttons-inline button { width: 90px;padding: 6px 8px; font-size: 12px; border-radius: 4px; border: none; cursor: pointer; text-align: center;}
.orange-btn { background-color: #ff6600; color: white;}
.gray-btn { background-color: gray; color: white;}
.filter-buttons-inline button { padding: 4px 8px; font-size: 12px; border-radius: 4px; border: none; margin-left: 5px; cursor: pointer;}
.gray-btn { background-color: gray; color: white;}
.filter-section.franchises .filter-buttons-inline button { width: 90px;}
.retail-classification .filter-header-row,.socioeconomic-status .filter-header-row,.avenue-classification .filter-header-row ,.franchises .filter-header-row {border-top: 2px solid #ccc; padding-top: 25px; padding-bottom: 0px; margin-bottom: 30px; display: flex; align-items: center; justify-content: space-between; font-size: 15px; font-weight: bold; margin: 0; font-family: 'Segoe UI', sans-serif;}
.retail-classification .filter-header-row h3, .socioeconomic-status .filter-header-row h3, .avenue-classification .filter-header-row h3,.location-filter .filter-header-row h3 {font-size: 12px; font-weight: bold; margin: 0; font-family: 'Segoe UI', sans-serif;}
.franchises .filter-header-row h3,.retail-classification .filter-header-row h3,.socioeconomic-status .filter-header-row h3,.avenue-classification .filter-header-row h3,.location-filter .filter-header-row h3 {font-size: 14px; font-weight: bold; margin: 0; font-family: 'Segoe UI', sans-serif;}
button.layer-active { background-color: #d0f0ff;border: 2px solid #007bff;font-weight: bold;font-family: 'Segoe UI', sans-serif;}
.filter-section.franchises .dropdown,.filter-section.franchises .toggle-btn,.filter-section.franchises summary span,.filter-section.franchises .subcategory-label,.filter-section.franchises .category-label,.filter-section.location-filter .state-label {font-family: 'Segoe UI', sans-serif; font-size: 12px !important;}
.filter-section.retail-classification label { font-family: 'Segoe UI', sans-serif; font-size: 12px !important; color: #333; margin-bottom: 10px; display: block;}
#operations-control-content,#pin-control-content,#nse-control-content,#location-control-content { padding-top:15px;margin-top: 15px;font-family: 'Segoe UI', sans-serif;}
#operations-control-content label,#pin-control-content label,#nse-control-content label,#location-control-content label { display: block;margin-bottom: 10px;}
.dropdown summary { position: relative; padding-right: 20px;}
.dropdown summary::after { content: "►"; position: absolute; right: 10px; font-size: 12px; transition: transform 0.2s ease; color: black; }
.dropdown[open] summary::after { content: "▼"; }
#pin-control-content > details.dropdown > summary::after { color: #ff6600; }
#avenue-control-content details.details-subcategory > summary::after {content: "►"; color: black; }
#avenue-control-content details.details-subcategory[open] > summary::after {content: "▼";}
#avenue-control-content > details.dropdown > summary::after {color: #ff6600;}
#pin-control-content details.details-subcategory > summary::after { content: "►"; color: black;}
 #pin-control-content details.details-subcategory[open] > summary::after { content: "▼"; }
#tooltip {position: absolute;pointer-events: none;background: rgba(0,0,0,0.75);color: #fff;padding: 4px 8px;border-radius: 4px;font-size: 12px;display: none;white-space: nowrap;transform: translate(-50%, -100%);}
#dev-toolbar {position: fixed;top: 10px;left: 50%;height: 30px;display: none;align-items: center;background-color:#ffffff;border: 5px solid #ff6600;border-radius: 10px;box-shadow: 0 2px 10px rgba(0,0,0,0.12);z-index: 1;padding: 5px 15px;transition: opacity 0.3s, width 0.3s;}
#dev-toolbar button {background: none;border: none;color: #ff6600;font-size: 15px;margin: 0 7px;cursor: pointer;border-radius: 7px;transition: 0.15s;padding: 5px 7px;}
#toolbar {position: fixed;top: 1%;left: 1%;display: flex;flex-direction: column;align-items: center;width: 50px;background-color: #ffffff;border: 5px solid #ff6600;border-radius: 5px;box-shadow: 0 2px 10px rgba(0,0,0,0.12);z-index: 9999;gap: 2px;padding: 8px 0;transition: opacity 0.3s ease;font-size: 14px;zoom: 1;will-change: transform;transform-origin: left center;}
#toolbar button {background: none;border: none;color: #ff6600;font-size: 15px;margin: 2px 0;cursor: pointer;border-radius: 7px;transition: 0.15s;}
#toolbar button:hover, #toolbar button.active-toggle {background: #0000;font-size: 16px;}
#toolbar-toggle {font-size: 15px;color: #0000;background: #ff6600;border-radius: 8px;padding: 4px 8px;}
.toolbar-hidden {background: #0000;width: 50px !important;opacity: 0.1;right: 1%;height: 30px;}
.toolbar-hidden #toolbar-toggle {margin: 3px;color: #ff6600;background: #0000;}
.toolbar-hidden button:not(#toolbar-toggle) {display: none;align-items: center;}
.toolbar-hidden .toolbar-divider {display: none !important;}
.filter-section {margin-bottom: 15px;}
.filter-header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; padding-bottom: 2px;font-family: 'Segoe UI', sans-serif;}
.filter-header-row h3 {font-size: 14px;font-weight: bold;margin: 0;font-family: 'Segoe UI', sans-serif;}
.filter-buttons-inline {display: flex;gap: 6px;font-family: 'Segoe UI', sans-serif;}
.filter-buttons-inline button {padding: 4px 8px;font-size: 12px;border-radius: 4px;border: none;cursor: pointer;min-width: 80px;text-align: center;font-family: 'Segoe UI', sans-serif;}
#pin-control-content,#operations-control-content,#avenue-control-content,#nse-control-content,#location-control-content {margin-top: 4px !important;padding-top: 4px !important;font-family: 'Segoe UI', sans-serif;}
.avenues-checkbox-group label {display: block;margin-bottom: 10px;font-family: 'Segoe UI', sans-serif;font-size: 13px;color: #333;}
#autocomplete-container {display: none; position: fixed;top: 290px;left: 85px;z-index: 10001;width: 390px;background: #ffffff;height: 20px;font-family: 'Segoe UI', sans-serif;transition: opacity 0.3s ease;}
#traffic-panel {display: none;position: fixed;top: 70px;right: 10px;width: 300px;max-height: 600px;overflow-y: auto;background: #ffffff;color: #000000;border: 8px solid #ff6600;border-radius: 8px;padding: 10px;z-index: 9999;font-family: 'Segoe UI', sans-serif;}
#bottom-image-container {position: fixed;bottom: 15px;left: 50%;transform: translateX(-50%);z-index: 99999;text-align: center;}
#bottom-image-container img {max-width: 50px;height: auto;display: block;cursor: pointer;}
#business-type {position: fixed;bottom: 100px;left: 10%;transform: translateX(-50%);display: flex;align-items: center;background-color:#ffffff;border: 3px solid #ff6600;border-radius: 10px;box-shadow: 0 2px 10px rgba(0,0,0,0.12);z-index: 9999;padding: 5px 15px;transition: opacity 0.3s, width 0.3s;}
#city-panel {display: none;position: fixed;top: 70px;right: 10px;width: 300px;max-height: 600px;overflow-y: auto;background: #ffffff;color: #000000;border: 8px solid #ff6600;border-radius: 8px;padding: 10px;z-index: 9999;font-family: 'Segoe UI', sans-serif;}
#search-box2 {position: fixed;top: 10px;right: 10px;z-index: 9999;background: white;padding: 8px;border-radius: 6px;box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);}
#poi-search-input {width: 450px;padding: 6px;font-size: 12px;}
#search-button2 {padding: 6px 10px;font-size: 14px;margin-left: 5px;}
body.dark-mode #toolbar {background-color: #666666;border-color: #383838;}
body.dark-mode #dev-toolbar {background-color: #666666;border-color: #383838;}
body.dark-mode #toolbar button {color: #ffffff;}
body.dark-mode #filter-panel  {background-color: #1d1d1d;border-color: #383838;color: #ffffff;}
body.dark-mode #filter-header {background-color: #383838;}
body.dark-mode .orange-btn {background-color: #383838;}
body.dark-mode .dropdown summary {background-color: #1d1d1d;}
body.dark-mode .dropdown summary {background-color: #1d1d1d;}
body.dark-mode .dropdown summary span.category-label{color: #ffffff;}
body.dark-mode .filter-section.retail-classification label {color: #ffffff;}
body.dark-mode .dropdown summary span.subcategory-label {color: #ff6600;}
body.dark-mode #popup2 {background-color: #1d1d1d;border-color: #383838;color: #ffffff;}
body.dark-mode #popup2 .popup-header {background-color: #383838;color: #ffffff;}
body.dark-mode #pin-control-content details.details-subcategory > summary::after {color: #ff6600;}
body.dark-mode #traffic-panel{background: #1d1d1d;border-color: #383838;color: #ffffff}
body.dark-mode #city-panel{background: #1d1d1d;border-color: #383838;color: #ffffff}
#export-files-panel{display: none;position: fixed;width: 200px;top: 16%;left: 5%;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;flex-direction: column;gap: 4px;}
body.dark-mode #export-files-panel{ background: #666666; border-color: #383838; color: #ffffff;}
body.dark-mode #export-research { color: #ffffff;}
body.dark-mode #btnLoadExcel { color: #ffffff;}
#poi-search-box{display: none;width: 400px;height: 20px;top: 220px;align-items: center;gap: 6px;position: fixed;left: 85px;z-index: 5;background: #ffffff;padding: 8px;border: 3px solid #ff6600;border-radius: 5px;box-shadow: 0 2px 5px rgba(0,0,0,0.1);}
body.dark-mode #poi-search-box{ background: #666666; border-color: #383838; color: #ffffff;}
#import-files-panel {display: none;position: fixed;width: 200px;top: 93px;left: 90px;background: #ffffff;border: 3px solid #ff6600;border-radius: 5px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 12px;color: black;padding: 10px 10px;flex-direction: column;gap: 6px;}
#import-analysis-toggle, #kmz-trigger{ color:#000000}
body.dark-mode #import-files-panel{ background: #666666; border-color: #383838; color: #ffffff;} body.dark-mode #kmz-trigger { color: #ffffff;} body.dark-mode #exportKmzBtn { color: #ffffff;} body.dark-mode #load-kmz-btn { color: #ffffff;}
#draw-tools-panel{display: none;position: fixed;width: 315px;top: 325px;left: 85px;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;flex-direction: column;gap: 4px;}
body.dark-mode #draw-tools-panel{ background: #666666; border-color: #383838; color: #ffffff;}
#ruler-toggle, #circle-toggle, #drawPolygonBtn, #local-pin-toggle { color:#000000}
body.dark-mode #ruler-toggle{ color: #ffffff;}
body.dark-mode #circle-toggle { color: #ffffff;}
body.dark-mode #drawPolygonBtn{ color: #ffffff;}
body.dark-mode #local-pin-toggle {color: #ffffff;}
#city-options-panel{display: none;position: fixed;width: 315px;top: 450px;left: 85px;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;flex-direction: column;gap: 4px;}
body.dark-mode #city-options-panel{ background: #666666; border-color: #383838; color: #ffffff;}
.option-item {display: flex;align-items: center;gap: 6px;}
.option-item input[type="checkbox"] {width: 12px;height: 12px;}
.option-item label { display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px;color: #000000 }
#residential-options-panel{display: none;position: fixed;width: 315px;top: 65px;left: 740px;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;flex-direction: column;gap: 4px;}
body.dark-mode #residential-options-panel{ background: #666666; border-color: #383838; color: #ffffff;}
#retail-options-panel{display: none;position: fixed;width: 250px;top: 475px;left: 85px;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;flex-direction: column;gap: 4px;}
body.dark-mode #retail-options-panel{background: #666666; border-color: #383838; color: #ffffff;}
#research-pin-form{display: none;position: fixed;top: 80px;right: 20px;background: #ffffff;border: 5px solid #ff6600;border-radius: 8px;width: 160px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 14px 14px;gap: 4px; }
body.dark-mode #research-pin-form{ background: #666666; border-color: #383838; color: #ffffff;}
#traffic-options-panel{display: none;position: fixed;width: 315px;top: 535px;left: 85px;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;flex-direction: column;gap: 4px;}
body.dark-mode #traffic-options-panel{ background: #666666; border-color: #383838; color: #ffffff;}
#settings-panel {display: none;position: fixed;width: 125px;top: 725px;left: 85px;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;}
body.dark-mode #settings-panel{ background: #666666; border-color: #383838; color: #ffffff;}
#settings-buttons {display: flex;flex-direction: row;justify-content: center;align-items: center;}
#settings-buttons button {background: none;border: none;cursor: pointer;}
#portfolio-options-panel{display: none;position: fixed;width: 315px;top: 625px;left: 85px;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;flex-direction: column;gap: 4px; }
#reports-options-panel {display: none;position: fixed;width: 315px;top: 620px;left: 85px;background: #ffffff;border: 3px solid #ff6600;border-radius: 8px;z-index: 10000;font-family: 'Segoe UI', sans-serif;font-size: 14px;color: #ff6600;padding: 8px 10px;flex-direction: column;gap: 4px;}
#notes-panel {position: fixed;top: 80px;right: 10px;width: 350px;height: 600px;background: #fafafa;border: 5px solid #383838;border-radius: 6px;box-shadow: 0 4px 12px rgba(0,0,0,0.15);display: none;flex-direction: column;padding: 20px;z-index: 10000;overflow-y: auto;}
#notes-header {display: flex;font-size: medium;justify-content: space-between;align-items: center;}
#note-input {width: 95%;height: 150px;margin: 10px 0;padding: 6px;resize: vertical;}
#save-note, #clear-notes {cursor: pointer;margin-bottom: 8px;}
#notes-list {flex: 1;overflow-y: auto;border-top: 1px solid #383838;padding-top: 8px;}
.note-item {background: #fff;border: 3px solid #1d1d1d;border-radius: 4px;padding: 6px;margin-bottom: 6px;position: relative;font-family: "Arial", sans-serif;font-size:   12px;}
.note-item button {position: absolute;top: 4px;right: 4px;background: none;border: none;cursor: pointer;}
#start-screen {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(39, 41, 40, 1);display: flex;align-items: center;justify-content: center;z-index: 9999;transition: opacity 0.5s ease;}
#start-screen img {max-width: 500px;max-height: 500px;}
#search-input{top: 10px;width: 100%;padding: 13px;border: 3px solid #ff6600;background: #ffffff;border-radius: 4px;font-size: 13px;}
body.dark-mode #search-input{ background: #666666; border-color: #383838; color: #ffffff;}
#municipios-panel {display: none; position: absolute;top: 70px;right: 10px;width: 265px;max-height: 400px;overflow-y: auto;background: rgba(255,255,255,0.95);padding: 8px;border: 5px solid #ff6600;border-radius: 5px;font-family: Arial, sans-serif;font-size: 14px;z-index: 100;box-shadow: 0 2px 6px rgba(0,0,0,0.3);}
#municipios-panel h3 { display: flex; align-items: center; justify-content: center; margin: 0 0 8px;font-size: 16px;height: 35px;background: #ff6600;position: relative;          color: #fff;                padding: 0 35px; }
#municipios-panel h3 button#municipios-close { position: absolute;top: 50%; right: 4px; transform: translateY(-50%); background: transparent;border: none;font-size: 16px;cursor: pointer;line-height: 1;color: #fff; }
#municipios-close {position: absolute;top: 2px;right: 2px;background: transparent;border: none;font-size: 16px;cursor: pointer;line-height: 1;}
#municipios-list label {display: block;margin-bottom: 10px;cursor: pointer;}
#municipios-list input {margin-right: 6px;}
#add-property-form {display: none;position: fixed;top: 10%;left: 89%;transform: translateX(-50%);background: #fff;padding: 16px;border: 2px solid #333;border-radius: 8px;z-index: 10000;font-family: sans-serif;width: 300px;}
#add-property-form input {width: 100%;margin-bottom: 8px;padding: 4px;}
#add-property-form button {margin-right: 8px;}
#portfolio-popup { position: absolute;top: 80px;right: 10px;width: 400px;height: 900px;background: white;border-radius: 8px;box-shadow: 0 2px 8px rgba(0,0,0,0.3);overflow: hidden;z-index: 10000; }
.gm-style .gm-style-iw-d { overflow: visible !important;max-height: none ;max-width:none; }
#loading-screen {position: fixed;top: 0; left: 0; right: 0; bottom: 0;background: rgba(255,255,255,0.8);z-index: 9999;display: flex;align-items: center;justify-content: center;}
.loading-content {text-align: center;font-size: 18px;color: #333;}
.spinner { margin: 0 auto 10px;border: 6px solid #ccc;border-top: 6px solid #FF6600;border-radius: 50%;width: 40px;height: 40px;animation: spin 1s linear infinite;}
@keyframes spin { to { transform: rotate(360deg); }}

</style>
</head>

<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBimPrRAY6NuxHcucxTpZ5hxW39CDnvnLM&callback=initMap&libraries=drawing,geometry,visualization" async defer></script>

<body>

  <div id="map" style="width:100%; height:100vh;"></div>
  
  <div id="tooltip"></div>

  <div id="poi-search-box">
  <input type="text" id="poi-search-input" placeholder="Search for any place..."
    style="padding: 10px; height: 15px; width: 250px; border: 0px solid #FF6600; background: #0000; font-size: 12px; border-radius: 0px; outline: none;">
  <button id="poi-search-button"style="background: none; border: none; font-size: 12px; font-weight: bold; cursor: pointer;">
    Search
  </button>
  <button id="poi-clear-button"
    style="background: none; border: none; font-size: 12px; font-weight: bold; cursor: pointer;">
    Clear
  </button>
</div>

<div id="toolbar" class="toolbar-visible">

<button id="filter-menu-button" title="Report Selection Menu"onclick="toggleMenu()"> <img id="menu-icon" src="https://static.wixstatic.com/media/449be3_efb74846942c4010997f65241fe00b57~mv2.png" style="width:25px; height:25px;"/> </button>    
<button id="save-analysis-toggle" title="Save Analysis"> <img  id="save-icon" src="https://static.wixstatic.com/media/449be3_ae9027a8001d4a1aab6f441526e5a2a5~mv2.png" style="width:25px; height:25px;"/> </button>
<button id="import-analysis-toggle" title="Open MKTS File" onclick="triggerImport()"> <img  id="import-icon" src="https://static.wixstatic.com/media/449be3_5f8d614c712d44aa803a8249bf90ed29~mv2.png" style="width:25px; height:25px;"/> </button>
<button id="import-files" title="Google Earth Options"> <img  id="earth-icon" src="https://static.wixstatic.com/media/449be3_616e422c37b847218109fae420477dad~mv2.png" style="width:25px; height:25px;"/></button>

<div class="toolbar-divider" style="width:24px; height:1px; background:#ccc; margin:0 8px;"></div>

<button id="poi-toggle-btn" title="Search Any Place in the Map"> <img id="poi-icon"src="https://static.wixstatic.com/media/449be3_a3e3349dbb4b475cb184913f46438d3e~mv2.png"style="width:25px; height:25px;"/></button>
<button id="activate-p" title="Show/Hide Google Maps Markers"> <img  id="activate-poi" src="https://static.wixstatic.com/media/449be3_cb25a1ae229c410bb3e788a2c180e80a~mv2.png" style="width: 25px; height: 25px;" /></button>  
<button id="search-toggle" title="Search Franchise in Database"> <img id="search-icon" src="https://static.wixstatic.com/media/449be3_8a261caa3a9241e3b23b8d7b13a59cb9~mv2.png" style="width:25px; height:25px;"/></button>
<button id="pin-toggle" title="My Location"><img  id="location-icon" src="https://static.wixstatic.com/media/449be3_0ecd16947ea34bc2b7bf5a4bbcc673b5~mv2.png" style="width:25px; height:25px;"/></button>
  
<div class="toolbar-divider" style="width:24px; height:1px; background:#ccc; margin:0 8px;"></div>

<button id="draw-tools" title="Draw Tools"> <img  id="draw-icon" src="https://static.wixstatic.com/media/449be3_c1607649ba094621bb1d4b0b8436582f~mv2.png" style="width:25px; height:25px;"/></button>
<button id="circle-toggle" title="Draw a Circle for Analysis"> <img  id="draw-icon" src="https://static.wixstatic.com/media/449be3_078aa5e71b784eecaac00d06dceb977f~mv2.png" style="width:25px; height:25px;"/></button>
  

<button id="city-toggle" title="City Limits"> <img  id="city-toggle" src="https://static.wixstatic.com/media/449be3_6aa423af54b643329802a75a09938edb~mv2.png"         style="width: 25px; height: 25px;" /></button> 
<button id="city-options" title="City Elements"><img  id="city-icon" src="https://static.wixstatic.com/media/449be3_bc900c0325a244cc9091944a62e450fe~mv2.png" style="width:25px; height:25px;"/> </button>
<button id="retail-options" title="Retail Options"> <img  id="retail-icon" src="https://static.wixstatic.com/media/449be3_16fa7ebbf2164a5999b2a4a98338c559~mv2.png" style="width:25px; height:25px;"/></button>
<button id="traffic-options" title="Traffic Options"> <img  id="traffic-icon" src="https://static.wixstatic.com/media/449be3_bf8224400dd5494ea792b314ae4b27c5~mv2.png" style="width:25px; height:25px;"/></button>

<button id="reports-options" title="Heatmap"> <img id="reports-icon"src="https://static.wixstatic.com/media/449be3_5f4ccffad98642e2b4adb1848c8dc623~mv2.png"style="width:25px; height:25px;"/> </button>

<div class="toolbar-divider" style="width:24px; height:1px; background:#ccc; margin:0 8px;"></div>

<button id="notes-toggle" title="Notepad"><img  id="notes-icon" src="https://static.wixstatic.com/media/449be3_252c73a1431944879025551f70f5ed3e~mv2.png" style="width:25px; height:25px;"/></button>

<button id="reset-button" title="Reset All"> <img  id="reset-icon" src="https://static.wixstatic.com/media/449be3_b2ab7e3e6cfd4d4f96749288fa7a580f~mv2.png" style="width:25px; height:25px;"/></button>
<button id="settings" title="Settings"><img  id="settings-icon" src="https://static.wixstatic.com/media/449be3_5fcc313481e340ceacc71cde244a0d5d~mv2.png" style="width:25px; height:25px;"/></button>
<button id="toolbar-toggle" title="Show/Hide toolbar" onclick="toggleToolbar()">▲</button></div>
</div>

<div id="import-files-panel">
<button id="kmz-trigger" title="Load KMZ Files" style=" display: flex;align-items: center;gap: 8px;background: none;border: none;cursor: pointer;padding: 4px 0;width: 100%;text-align: left;">
    <img src="https://static.wixstatic.com/media/805cf6_9e94c6cb1de3464dbc5db7a3d9fa9476~mv2.png" alt="Search" style="width:20px; height:20px;" />
    <span>Open KMZ File</span>
  </button>
  <button id="exportKmzBtn" title="Download Pins & Polygons to KMZ" style="display: flex;align-items: center;gap: 8px;background: none;border: none;cursor: pointer;padding: 4px 0;width: 100%;text-align: left;">
    <img src="https://static.wixstatic.com/media/805cf6_9e94c6cb1de3464dbc5db7a3d9fa9476~mv2.png" style="width: 20px; height: 20px;" />
    <span>Export to KMZ</span>
  </button>


<input type="file" id="kmz-input" accept=".kmz" style="display: none;" />
</div>

<div id="draw-tools-panel">
<button id="local-pin-toggle" title="Add a Custom Marker" onclick="activatePinMode" style="display: flex;align-items: center;gap: 8px;background: none;border: none;cursor: pointer;padding: 4px 0;width: 100%;text-align: left;"> <img src="https://img.icons8.com/?size=48&id=85049&format=png" style="width: 20px; height: 20px;" /> <span>Add a Custom Marker</span> </button>
<button id="expansion-pin-btn"
        title="Add Expansion Pin"
        style="display:flex;align-items:center;gap:6px;background:none;border:none;cursor:pointer;padding:4px 0;">
  <img src="https://img.icons8.com/?size=48&id=85049&format=png" style="width: 20px; height: 20px;" />
  <span>Expansion Pin</span>
</button>


  <button id="ruler-toggle" title="Point A to B Distance" style="
    display: flex;
    align-items: center;
    gap: 8px; /* ← menos espacio entre ícono y texto */
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
  ">
    <img src="https://img.icons8.com/?size=60&id=78651&format=png" style="width: 20px; height: 20px;" />
    <span>Distance from A to B</span>
  </button>
<button id="drawPolygonBtn" title="Draw a Custom Polygon" style="
display: flex;
align-items: center;
gap: 8px;
background: none;
border: none;
cursor: pointer;
padding: 4px 0;
width: 100%;
text-align: left;
">
<img src="https://img.icons8.com/?size=60&id=78727&format=png" style="width: 20px; height: 20px;" />
<span>Draw a Polygon</span>
</button>
</div>

<div id="city-options-panel">

    <div class="option-item">
    <input type="checkbox" id="opt-airports" />
    <label for="opt-airports">
      <img src="images/icons/airports.png" width="15" height="15" />
      Airports
    </label>
  </div>


  <div class="option-item">
    <input type="checkbox" id="opt-audience" />
    <label for="opt-audience">
      <img src="images/icons/ticket.png" width="20" height="20" />
      Audience & Concerts Venues
    </label>
  </div>



  <div class="option-item">
    <input type="checkbox" id="opt-evcs" />
    <label for="opt-evcs">
      <img src="images/icons/evcs.png" width="20" height="20" />
      Electric Vehicles Charging Stations
    </label>
  </div>




  <div class="option-item">
    <input type="checkbox" id="opt-public-parks" />
    <label for="opt-public-parks">
      <img src="images/icons/park.png" width="20" height="20" />
      Public Parks
    </label>
  </div>


  <div class="option-item">
    <input type="checkbox" id="opt-stadiums" />
    <label for="opt-stadiums">
      <img src="images/icons/stadium.png" width="20" height="20" />
      Sport Stadiums
    </label>
  </div>



  <div class="option-item">
    <input type="checkbox" id="opt-schools" />
    <label for="opt-schools">
      <img src="images/icons/school.png" width="20" height="20" />
      Universities & Highschools
    </label>
  </div>




  <div class="option-item">
    <input type="checkbox" id="opt-urbantrain" />
    <label for="opt-urbantrain">
      <img src="images/icons/train.png" width="20" height="20" />
      Urban Train Stations
    </label>
  </div>


</div>

<div id="retail-options-panel">
  <button id="toggle-all-properties" style="margin-bottom:8px;">
    Show/Hide
  </button>
  <div style="display:flex; flex-direction:column; gap:4px;">
    <label>
      <input type="checkbox" id="toggle-locales-renta" data-cat="localesRenta" />
      Retail Spaces Rent
    </label>
    <label>
      <input type="checkbox" id="toggle-locales-venta" data-cat="localesVenta" />
      Retail Spaces Sale
    </label>
    <label>
      <input type="checkbox" id="toggle-terrenos-renta" data-cat="terrenosRenta" />
      Land Lot Rent
    </label>
    <label>
      <input type="checkbox" id="toggle-terrenos-venta" data-cat="terrenosVenta" />
      Land Lot Sale
    </label> 
  </div>
  </div>

  <div id="traffic-options-panel">
  <button id="traffic-toggle" title="Shopping Malls" style="display: flex;align-items: center;gap: 8px;background: none;border: none;cursor: pointer;padding: 4px 0;width: 100%;text-align: left;"> <img src="https://img.icons8.com/?size=60&id=62912&format=png" style="width: 20px; height: 20px;" /> <span>Main Thoroughfares</span> </button>
  
  <button id="traffic-vehicles-toggle" title="Shopping Malls" style=" display: flex;align-items: center;gap: 8px;background: none;border: none;cursor: pointer;padding: 4px 0;width: 100%;text-align: left;"> <img src="https://img.icons8.com/?size=50&id=10734&format=png" style="width: 20px; height: 20px;" /> <span>Traffic Live</span> </button>
  <button id="traffic-segment-speed" title="Shopping Malls" style="
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px 0;
  width: 100%;
  text-align: left;
  ">
  <img src="https://img.icons8.com/?size=48&id=vwGXRtPWrZSn&format=png" style="width: 20px; height: 20px;" />
  <span>Historic Traffic</span>
  </button>
  
  </div>  

  <div id="reports-options-panel">
    <button
      id="heatmap-toggle"
      title="Heatmap ON"
      style="
        display: flex;
        align-items: center;
        gap: 8px;
        background: none;
        border: none;
        cursor: pointer;
        padding: 4px 0;
        width: 100%;
        text-align: left;
      "
    >
      <img
        src="images/icons/heatmap.png"
        style="width:20px; height:20px;"
      />
      <span>Heatmap ON</span>
    </button>

    <label
  for="heatmap-radius"
  style="display:inline-block; margin: 0 0 0 12px; font-size:12px; color:#333;"
>
  Radio: <span id="heatmap-radius-value">100</span> m
</label>
<input
  type="range"
  id="heatmap-radius"
  min="100"
  max="5000"
  step="100"
  value="100"
  style="vertical-align:middle; margin-left:4px;"
/>
  </div>
  

  <div id="settings-panel">
    <button id="sound-toggle" style="
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
    ">
    <img src="https://img.icons8.com/?size=48&id=iWO20ZvCeU53&format=png" title="Sound Effects" style="width: 20px; height: 20px;" />
    </button>
    <button id="dark-mode" style="
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
    ">
    <img id="dark-mode-icon" src="https://img.icons8.com/?size=60&id=59841&format=png" title="Dark Mode" style="width: 20px; height: 20px;" />
    </button>
    <button id="dev-mode"  style="
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
    ">
    <img src="https://img.icons8.com/?size=48&id=vJB83aasOd9i&format=png" title="Developer Tools" style="width: 20px; height: 20px;" />
    </button>
    
    </div>  

    <div id="dev-toolbar" class="toolbar-visible">


  <button id="pins-research" title="Add to Database">
    <img  id="retail-icon" 
    src="images/icons/database-add.png" 
    style="width:25px; height:25px; display: flex;"
    />
  </button>


  <button id="toggle-radius-limit" title="Increase Circle Radius">
    <img  id="retail-icon" 
    src="images/icons/circle-increase.png" 
    style="width:25px; height:25px; display: flex;"
    />
  </button>


    <button id="export-research" title="Download Custom Markers & Polygons to XLS">
    <img  id="export-excel" 
    src="images/icons/xls.png" 
    style="width:25px; height:25px; display: flex;"
    />
  </button>


  <button onclick="sendResearchPins()">Enviar a Google Sheets</button>


</div>     




<div id="bottom-image-container"> <a href="https://www.marketspots.mx" rel="noopener"> <img src="https://static.wixstatic.com/media/805cf6_1f6e397fdb7449bcbfda8dc022a66870~mv2.png" alt="Ir a mi sitio web" /> </a> </div>



<div id="notes-panel">
  <div id="notes-header">
    <h2>Notes</h2>
    <button id="clear-notes" title="Erase Notes?">🗑️</button>
  </div>
  <textarea id="note-input" placeholder="Write something here..."></textarea>
  <button id="save-note" class="orange-btn">Save</button>
  <div id="notes-list"></div>
</div>  
<div id="traffic-panel" style="display: none;
">
<div style="display: flex; justify-content: space-between; align-items: center; font-weight: bold; margin-bottom: 10px;">
  Traffic Generators
  <button onclick="closeTrafficPanel()">✕</button>
</div>
<div id="avenue-control-content"></div>
<div style="margin-top: 10px; display: flex; justify-content: flex-end; gap: 8px;">
  <button class="gray-btn" style="font-size: 12px; padding: 6px 14px; min-width: 90px;" id="clearAllAvenues">Clear</button>
  <button class="orange-btn" style="font-size: 12px; padding: 6px 14px; min-width: 90px;" id="selectAllAvenues">Select All</button>
</div>
</div>
<div id="city-panel" style="display: none;">
<div style="display: flex; justify-content: space-between; align-items: center; font-weight: bold; margin-bottom: 10px;">
  City Boundaries
  <button onclick="closeCityPanel()">✕</button>
</div>
<div id="location-control-content"></div>
<div style="margin-top: 10px; display: flex; justify-content: flex-end; gap: 8px;">
  <button class="gray-btn" style="font-size: 12px; padding: 6px 14px; min-width: 90px;" id="clearAllLocations">Clear</button>
  <button class="orange-btn" style="font-size: 12px; padding: 6px 14px; min-width: 90px;" id="selectAllLocations">Select All</button>
</div>
</div>
<div id="autocomplete-container">
<div style="position: relative;">
<input id="search-input" type="text" style="font-size: 12px;" placeholder="Search Franchise or Location">
<div id="autocomplete-results" style="
position: absolute;
top: 100%;
left: 0;
width: 420px;     	     	
max-height: 275px;
overflow-y: auto;
margin-top: 4px;
border: 1px solid #ccc;
border-radius: 5px;
background: #ffffff;
display: none;
font-size: 12px;
z-index: 10000;
"></div>
</div>
</div>
<div id="popup" class="popup">
  <span class="popup-close" onclick="closePopup()">X</span>
  <div class="popup-header" id="popup-header"></div>
  <div class="popup-content" id="popup-content"></div>
  <button onclick="downloadExcel()">Download Report (Excel)</button>
</div>
<div id="popup2" class="popup">
  <div class="popup-header">
    <span id="popup2-header" style="margin: 0 auto; text-align: center; width: 100%;"></span>
    <span class="popup-close" onclick="closePopup2()">X</span>
  </div>
  <div id="franchise-section">
    <div class="popup-inline-data" style="text-align:center; font-weight: bold; margin-top: 10px; font-size: 12px;">
      Franchises Top 5
    </div>
    <div id="franchisechart"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <div id="subcategory-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px;">
      Subcategories Top 5
    </div>
    <div id="subcategorychart"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <div id="operation-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px;">
      Retail Classification
    </div>
    <div id="operationPieChart"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <div id="operation-list-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px; color: #ff6600;">
      Shopping Centers on Radius:
    </div>
    <div id="operation-list" style="padding: 10px 20px; font-size: 12px; line-height: 1.6;"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <div id="scatter-section">
    <div class="popup-inline-data" style="display: flex; flex-direction: column; align-items: center; margin-top: 20px; font-size: 12px;">
      <div style="font-weight: bold; margin-bottom: 8px;">
        Marketplace Properties
      </div>
      <select id="category-select" style="padding:4px 8px; font-size:12px;">
        <option value="localesRenta">Retail Spaces / Rent</option>
        <option value="localesVenta">Retail Spaces / Sale</option>
        <option value="terrenosRenta">Land Lot / Rent</option>
        <option value="terrenosVenta">Land Lot / Sale</option>
      </select>
    </div>
    <div id="scatterchart" style="width:100%; height:135%; margin-top: 10px;"></div>
    <div id="scatter-summary" style="padding:8px 0; font-size:14px; text-align:center;"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <div id="nse-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px;">
      Influence Area by Socioeconomic Status
    </div>
    <div id="piechart"></div>
    <div class="popup-inline-data" id="popup2-extra" style="text-align:center; margin-top: 20px; font-size: 12px;"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <div id="list-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px;">
      Franchises Full List in Current Radius:
    </div>
    <div id="franchise-list" style="padding: 20px; font-size: 12px;"></div>
    <div style="text-align: center; margin: 20px 0;">
      <button onclick="downloadExcel()">Download Report (Excel)</button>
    </div>
  </div>
</div>


</div>


<div id="filter-panel">

<div id="filter-header">

<span>Report Selection Menu</span>

<button onclick="toggleMenu()"></button></div>

<div id="filter-content">

<div class="filter-section location-filter">
  <div class="filter-header-row">
              	<h3>Locations:</h3>
              	<div class="filter-buttons-inline">
             	<button id="clearAllLocationsFilter" class="gray-btn">Clear</button>
             	<button id="selectAllLocationsFilter" class="orange-btn">Select All</button>
              	</div>
  </div>
  <div id="location-filter-content"></div>

</div>





<div class="filter-section franchises">     	
  <div class="filter-header-row">
<h3>Companies List:</h3>
<div class="filter-buttons-inline">
<button onclick="deselectAllMarkers()" class="gray-btn">Clear</button>
<button onclick="selectAllMarkers()" class="orange-btn">Select All</button>
</div>
</div>

<div id="pin-control-content"></div>
</div>
<div class="filter-section retail-classification">
<div class="filter-header-row">
<h3>Retail Classification:</h3>
<div class="filter-buttons-inline">
<button id="selectAllOperations" class="orange-btn">Select All</button>
</div>
</div>
<div id="operations-control-content"></div>
</div>
<div class="filter-section socioeconomic-status">
<div class="filter-header-row">
<h3>Socioeconomic:</h3>
<div class="filter-buttons-inline">
<button id="clearAllNSE" class="gray-btn">Clear</button>
<button id="selectAllNSE" class="orange-btn">Select All</button>
</div>
</div>
<div id="nse-control-content"></div>
</div>


</div>
</div>
</div>
<div id="ruler-popup" style="
  display: none;
  position: fixed;
top: 12px;
right: 250px;
transform: translateX(-50%);
  background: #000000;
  border: 0px solid #ffffff;
  border-radius: 6px;
  padding: 10px 40px;
  z-index: 5;
  font-family: 'Segoe UI', sans-serif;
  font-size: 13px;
  color: #ffffff;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
">
 <span id="ruler-popup-text">Distance: </span>
 <span style="margin-left: 15px; cursor: pointer; font-weight: bolder; font-size: 14px; color: #ffffff;" onclick="closeRulerPopup()">✕</span>
 
</div>
<div id="toast"></div>
 
 
<div id="research-pin-form">
	<label>Franchise:</label><br>
	<input id="research-franchise" type="text"><br>
  <label>Operations:</label><br>
  <input id="research-operations" type="text" style="top:50px" list="operations-options"><br>
  <datalist id="operations-options">
    <option value="Airports"></option>
    <option value="Community Centers">
    <option value="Free Standings">
    <option value="Neighborhood Centers">
    <option value="Power Centers">
    <option value="Shopping Malls">
  </datalist>
	<label>Address:</label><br>
	<input id="research-address" type="text"><br>
  <label>Location:</label><br>
  <input id="research-location" type="text" style="top:50px" list="municipality-options"><br>
  <datalist id="municipality-options">
    <option value="Altamira">
    <option value="Apodaca">
    <option value="Ciénega de Flores">
    <option value="Ciudad Madero">
    <option value="El Carmen">
    <option value="Escobedo">
    <option value="García">
    <option value="Guadalupe">
    <option value="Juárez">
    <option value="Laredo TX">
    <option value="Monterrey">
    <option value="Pesquería">
    <option value="Salinas Victoria">
    <option value="San Nicolás de los Garza">
    <option value="San Pedro Garza García">
    <option value="Santa Catarina">
    <option value="Santiago">
    <option value="Tampico">
    <option value="Zuazua">
  </datalist>
  <div style="margin-top: 30px;">
    <button class="orange-btn"; onclick="saveResearchPin()">Guardar</button>
    <button class="gray-btn"; onclick="closeResearchPinForm()">Cancelar</button>
  </div>
</div>
<div id="polygon-tooltip" style="
  position: absolute;
  display: none;
  background: black;
  color: white;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 13px;
  pointer-events: none;
  z-index: 9999;
  white-space: nowrap;
"></div>
<div id="start-screen">
  <img src="https://i.gifer.com/embedded/download/Gpoq.gif"/>
</div>
<div id="municipios-panel">
  <h3>
    City Limits
    <button id="municipios-close" title="Cerrar">&times;</button>
  </h3>
  <div class="btn-group" style="text-align: center; margin-bottom: 8px;">
    <button id="selectAllMunicipios" class="gray-btn">Select All </button>
    <button id="clearAllMunicipios" class="orange-btn"> Clear All </button>

  </div>
  <div id="municipios-list"></div>


</div>

<div id="loading-screen" style="display:none;">
  <div class="loading-content">
    <div class="spinner"></div>
    <div id="loading-timer" style="font-size:24px; margin:8px 0;">00:00</div>
    <p>Processing...</p>
  </div>
</div>


<script>
function showToast(message) {
let toast = document.getElementById("toast");
const fullscreenEl = document.fullscreenElement;
if (!toast) {
toast = document.createElement("div");
toast.id = "toast";
toast.style.position = "fixed";
toast.style.top = "10%";
toast.style.left = "50%";
toast.style.transform = "translateX(-50%)";
toast.style.backgroundColor = "#ff6600";
toast.style.color = "white";
toast.style.padding = "10px 20px";
toast.style.borderRadius = "6px";
toast.style.fontSize = "14px";
toast.style.zIndex = "100";
toast.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
toast.style.transition = "opacity 0.5s ease"; 
toast.style.opacity = "0"; 
 (fullscreenEl || document.body).appendChild(toast);
} else {
  if (fullscreenEl && toast.parentNode !== fullscreenEl) {
              	fullscreenEl.appendChild(toast);
  } else if (!fullscreenEl && toast.parentNode !== document.body) {
              	document.body.appendChild(toast);
  }
}
toast.textContent = message;
toast.style.display = "block";
toast.style.opacity = "1";
clearTimeout(toast.hideTimeout);
toast.hideTimeout = setTimeout(() => {
toast.style.opacity = "0"; 
setTimeout(() => {
              	toast.style.display = "none";
  }, 500);
}, 5000);
}

function setBaseFranchise(marker) {
  const km          = parseFloat(prompt('Base radius (km):', (maxCircleRadius / 1000))) || (maxCircleRadius / 1000);
  const radius      = km * 1000;
  const numResults  = parseInt(prompt('How many candidates to show?','3'),10) || 3;
  const threshold   = parseInt(prompt('Minimum threshold (0–100):','85'),10) || 85;

  const baseMetrics = getMetrics(marker.getPosition(), radius);

  baseFranchiseParams = {
    franchiseName: marker.franchise,
    center:        marker.getPosition(),
    radius,
    numResults,
    threshold,
    baseMetrics
  };

  showToast(`🚩 Base established: ${marker.franchise}`);
}


const nseColors = {"A/B+": "#41934B", "C+": "#FF6600", "C": "#EFB451","C-": "#967164", "D+": "#2F267C", "D": "#56A8DE", "E": "#FF0000",};
let map= []; markers = [], polygons = [], currentCircle = null, currentCircleData = [];
let activeAvenues = new Set();
let activeLocations = new Set();
let activeLocationsFilter = new Set();
let activeNSEs = new Set();
let activeOperations = new Set();
let chartsColor = "transparent";
let chartsTextColor = "#ff6600"
let currentKmzLayer = null;
let currentPolygon = null;
let customPolygons = [];
let drawnCircle = null;
let drawingManager;
let drawnPolygons = [];
let fillOpacityLevel = 0.1;
let heatmap;
let importedKMZ = [];
let infoWindow;
let isDarkMode = false;
let isRestoringCityBoundaries = false;
let isSoundEnabled = localStorage.getItem('soundEnabled') === 'true';
let localMarkers = [];
let localPins = [];
let locationPolygons = {};
let mapClickListener = null;
let maxCircleRadius = 3500;
let nsePolygons = {};
let pinMode = null;
let poiMarkers = [];
let polylines = [];
let popup2Data = null;
let researchPinMode = false;
let addPortfolioMarker = false;
let rulerColor = "#000000"
let rulerListener = null;
let rulerPoints = [];
let rulerPolyline = null;
let selectedResearchCoords = null;
let tempDistanceLabel = null;
let tempRulerLine = null;
let tooltipTimeout;
let tooltipDiv;
let tooltipOverlay;
let trafficLayer;
let userLocationMarker = null;
let wasFilterPanelOpen = false;
let wasCityPanelVisible = false;
let wasPopupVisible = false;
let wasPopup2Visible = false;
let wasRulerPopupVisible = false;
let wasTrafficPanelVisible = false;
let inmobiliariaLoaded = false;      
let inmuebleMarkers = [];            
let inmuebleVisible = false;    

let wktCache = {};

let analysisCircles = [];
let analysisMarkers = [];
let currentAnalyzedFranchise = null;
let baseFranchiseParams = null;
let currentExpansionMarker = null;
let expansionPinMode = false;
let avgMsPerPoint = null;


window.importedKMZMarkers  = window.importedKMZMarkers  || [];
window.importedKMZPolygons = window.importedKMZPolygons || [];

let circleColor = isDarkMode ? "#ff6600" : "#000000"; 

let propRadius = 50;


let retailSpaceRent = "#FFE700"
let retailSpaceSale = "#00FF00"
let landLotSale = "#FF0000"
let landLotRent = "#0000FF"


const SHEET_PINS1_URL = 
"https://docs.google.com/spreadsheets/d/e/2PACX-1vQ5kbzFC8KW-W-nN3kHkcGRV2tjWF_bJjSe-hsfmm8JQTZ_ZsY8S6Toc-jt6RDKDGVXE3CMWGilp52T/pub?gid=101179819&single=true&output=csv";

const SHEET_PINS2_URL = 
"https://docs.google.com/spreadsheets/d/e/2PACX-1vQ5kbzFC8KW-W-nN3kHkcGRV2tjWF_bJjSe-hsfmm8JQTZ_ZsY8S6Toc-jt6RDKDGVXE3CMWGilp52T/pub?gid=928048829&single=true&output=csv";

const SHEET_NSE_URL = 
"https://docs.google.com/spreadsheets/d/e/2PACX-1vR9CUmue2eopaly_vepho2L9-W1hbKCWceeQw6aTHUfhX0vVtQRcDDdaXNvCN7DgtpEKSiEvbJFb68d/pub?gid=1770754104&single=true&output=csv";

const SHEET_TRAFFIC = 
"https://docs.google.com/spreadsheets/d/e/2PACX-1vRG8BfgGTQhABMwVhfcC1N4yWMr8cuiA03y5u9CXBpYWwuvw_XpIVafVYXvvyOCCkzWCO4BHOcGsiLR/pub?gid=0&single=true&output=csv";

const SHEET_LOCATIONS_URL = 
"https://docs.google.com/spreadsheets/d/e/2PACX-1vQM4pK2eOKZCYmY99fWLDRnTkqHgLOxPPbM7xX0tY58zAC00httARbYXezo46H6PTu7sSQVfkpxd1pJ/pub?gid=0&single=true&output=csv";


const startScreen = document.getElementById('start-screen');
  setTimeout(() => {
    startScreen.style.opacity = '0';
    startScreen.addEventListener('transitionend', () => {
      startScreen.style.display = 'none';
    });
  }, 6500);

const cities = ['altamira','ciudad-madero','durango-durango','gomez-palacio','lerdo','tampico','apodaca','escobedo','general-escobedo','garcia','guadalupe','guadalupe-nuevo-leon','juarez-nuevo-leon','saltillo',
'monterrey','san_nicolas','san_nicolas_de_los_garza','san-nicolas-de-los-garza','san_pedro','san-pedro-garza-garcia','san-pedro-garza-garcía','matamoros-tamaulipas','monclova','nuevo-laredo','piedras-negras','reynosa','torreon',
'santa_catarina','santa_catarina_nuevo_leon','santa-catarina-nuevo-leon','victoria-tamaulipas'];

const baseFolder = 'files/props_data';
const propertyConfig = {
  localesRenta: {prefixFolder: `${baseFolder}/noreste`,filePrefix:   'locales-renta',isMarker:     false,circleOptions:{ color: retailSpaceRent, radius: propRadius }},
  localesVenta: {prefixFolder: `${baseFolder}/noreste`,filePrefix:   'locales-venta',isMarker:     false,circleOptions:{ color: retailSpaceSale, radius: propRadius }},
  terrenosRenta: {prefixFolder: `${baseFolder}/noreste`,filePrefix:   'terrenos-comerciales-renta',isMarker:     false,circleOptions:{ color: landLotRent , radius: propRadius }},
  terrenosVenta: {prefixFolder: `${baseFolder}/noreste`,filePrefix:   'terrenos-comerciales-venta',isMarker:     false,circleOptions:{ color: landLotSale, radius: propRadius }}
};
const propertyMarkers = { localesRenta:[], localesVenta:[], terrenosRenta:[], terrenosVenta: [] };
const propertyVisible = { localesRenta:false, localesVenta:false, terrenosRenta:false, terrenosVenta:false};
  async function loadCategory(category) {
  const cfg      = propertyConfig[category];
  const overlays = propertyMarkers[category];
  if (overlays.length) return;
  for (const city of cities) {
    for (let page = 1; ; page++) {
      const url = `${cfg.prefixFolder}/${city}_${cfg.filePrefix}_p${page}.json`;


      try {
        const res  = await fetch(url);
        if (!res.ok) break;
        const data = await res.json();
        data.forEach(item => {
          const lat = parseFloat(item.Lat),
                lng = parseFloat(item.Lng);
          if (isNaN(lat) || isNaN(lng)) return;
          let overlay;
          if (cfg.isMarker) {
            overlay = new google.maps.Marker({
              position: { lat, lng },
              map,
              visible: false,
              title: item.Título,
              icon: {
                url: cfg.iconUrl,
                scaledSize: new google.maps.Size(30, 32),
              zIndex: 3

              }
            });
          } else {
            overlay = new google.maps.Circle({
              center:   { lat, lng },
              radius:   cfg.circleOptions.radius,
              strokeColor: "#FFFFFF",
              strokeWeight: 0,
              fillColor: cfg.circleOptions.color,
              fillOpacity: .85,
              map,
              visible: false,
              zIndex: 3
            });
          }
          overlay._props = {
            título:     item.Ubicación,
            superficie: item.Superficie,
            precio:     item.Precio,
            enlace:     item.Enlace   
          };
          overlay.addListener('click', () => {
  const url = overlay._props.enlace;
  if (url) {
    const fullUrl = url.startsWith('http') ? url : `https://${url}`;
    window.open(fullUrl, '_blank');
  }
});
overlay.addListener('mouseover', e => {
  const { título, superficie, precio } = overlay._props;
  const supNum = Number(
    superficie.toString().replace(/[^\d.-]/g, '')
  );
  const preNum = Number(
    precio.toString().replace(/[^\d.-]/g, '')
  );
  const supStr = isNaN(supNum)
    ? 'N/A'
    : supNum.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' m²';
  const preStr = isNaN(preNum)
    ? 'N/A'
    : '$' + preNum.toLocaleString(undefined, { maximumFractionDigits: 0 });
  let valorM2Str = 'N/A';
  if (!isNaN(supNum) && supNum > 0 && !isNaN(preNum)) {
    const valorM2 = preNum / supNum;
    valorM2Str = '$' + valorM2
      .toLocaleString(undefined, { maximumFractionDigits: 0 });
  }
  tooltipDiv.innerHTML = `
    <div style="
      background: black;
      color: white;
      padding: 6px 8px;
      border-radius: 1px;
      font-size: 12px;
    ">
      <strong>${título}</strong><br>
      Area: ${supStr}, Ticket: ${preStr}, MX/m²: ${valorM2Str}
    </div>
  `;
  tooltipDiv.style.display = 'block';
});
          overlay.addListener('mousemove', e => {
            const proj = tooltipOverlay.getProjection();
            const pos  = proj.fromLatLngToDivPixel(e.latLng);
            tooltipDiv.style.left = pos.x + 'px';
            tooltipDiv.style.top  = pos.y + 'px';
          });
          overlay.addListener('mouseout', () => {
            tooltipDiv.style.display = 'none';
          });
          overlays.push(overlay);
        });
      } catch (e) {
        console.warn(`No se encontró ${url}, deteniendo ${category}/${city}`, e);
        break;
      }
    }
  }
  console.log(`✅ Cargada categoría ${category}: ${overlays.length} objetos.`);
}
  function toggleCategory(category, visible) {
    propertyVisible[category] = visible;
    propertyMarkers[category].forEach(o => o.setVisible(visible));
  }
  function toggleAllProperties() {
    const anyVisible = Object.values(propertyVisible).some(v => v);
    const newState   = !anyVisible;
    Object.keys(propertyVisible).forEach(cat => {
      propertyVisible[cat] = newState;
      propertyMarkers[cat].forEach(o => o.setVisible(newState));
      document
        .querySelector(`#toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`)
        .checked = newState;
    });
  }
</script>
<script>
const darkMapStyle = [
{ elementType: 'geometry', stylers: [{ color: '#1d1d1d' }] },
  { elementType: 'labels.icon', stylers: [{ visibility: 'off' }] },
  { elementType: 'labels.text.fill', stylers: [{ color: '#616161' }] },
  { elementType: 'labels.text.stroke', stylers: [{ color: '#0000' }] },
  { featureType: 'administrative', elementType: 'geometry', stylers: [{ color: '#FF6600' }] },
  { featureType: 'poi', elementType: 'geometry', stylers: [{ color: '#000000' }] },
  { featureType: 'poi', elementType: 'labels.text.fill', stylers: [{ color: '#FF6600' }] },
  { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#383838' }] },
  { featureType: 'road.arterial', elementType: 'labels.text.fill', stylers: [{ color: '#383838' }] },
  { featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: '#383838' }] },
  { featureType: 'transit', elementType: 'geometry', stylers: [{ color: '#0000' }] },
  { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#000000' }] },
  { featureType: 'water', elementType: 'labels.text.fill', stylers: [{ color: '#000000' }] }
];
const lightMapStyle = [
 { elementType: 'geometry', stylers: [{ color: '#f5f5f5' }] },
 { elementType: 'labels.icon', stylers: [{ visibility: 'off' }] },
 { elementType: 'labels.text.fill', stylers: [{ color: '#616161' }] },
 { elementType: 'labels.text.stroke', stylers: [{ color: '#f5f5f5' }] },
 { featureType: 'administrative', elementType: 'geometry', stylers: [{ color: '#c9c9c9' }] },
 { featureType: 'administrative.neighborhood', stylers: [{ visibility: 'off' }] },
 { featureType: 'poi', elementType: 'geometry', stylers: [{ color: '#eeeeee' }] },
 { featureType: 'poi', elementType: 'labels.text.fill', stylers: [{ color: '#757575' }] },
 { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#dadada' }] },
 { featureType: 'road.arterial', elementType: 'labels.text.fill', stylers: [{ color: '#333333' }] },
 { featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: '#dadada' }] },
 { featureType: 'transit', elementType: 'geometry', stylers: [{ color: '#e5e5e5' }] },
 { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#E1f6ff' }] },
 { featureType: 'water', elementType: 'labels.text.fill', stylers: [{ color: '#9e9e9e' }] }
];

function initMap() {
    map = new google.maps.Map(document.getElementById("map"), {
    center: { lat: 25.6860, lng: -100.3169 }, 
    zoom: 7,
    styles: lightMapStyle,
    mapTypeControl: true,
    mapTypeControlOptions: {
      style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
      position: google.maps.ControlPosition.TOP_RIGHT,
      mapTypeIds: ["roadmap", "satellite"]
    },
    fullscreenControl: true,
    fullscreenControlOptions: { position: google.maps.ControlPosition.TOP_RIGHT },
    streetViewControl: true,
    streetViewControlOptions: { position: google.maps.ControlPosition.TOP_RIGHT }
  
  });


const savedCenter = JSON.parse(localStorage.getItem("mapCenter"));
const savedZoom   = Number(localStorage.getItem("mapZoom"));
if (savedCenter && !isNaN(savedZoom)) {
 map.setCenter(savedCenter);
 map.setZoom(savedZoom);
}
map.addListener("idle", () => {
 const c = map.getCenter();
 localStorage.setItem("mapCenter", JSON.stringify({ lat: c.lat(), lng: c.lng() }));
 localStorage.setItem("mapZoom", map.getZoom());
});  

localStorage.removeItem("customPolygons"); localStorage.removeItem("customPins"); localStorage.removeItem("importedKMZ"); localStorage.removeItem("excelData");

  tooltipDiv     = document.getElementById("tooltip");
  tooltipOverlay = new google.maps.OverlayView();
  tooltipOverlay.onAdd = function() {
    this.getPanes().overlayMouseTarget.appendChild(tooltipDiv);
  };
  tooltipOverlay.draw = function() { };
  tooltipOverlay.onRemove = function() {
    tooltipDiv.parentNode && tooltipDiv.parentNode.removeChild(tooltipDiv);
  };
  tooltipOverlay.setMap(map);
updateSoundButton();

    document.addEventListener("DOMContentLoaded", () => {
      const elem = document.documentElement;

      if (elem.requestFullscreen) {
        elem.requestFullscreen();
      } else if (elem.webkitRequestFullscreen) { 
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) { 
        elem.msRequestFullscreen();
      }
    });

let hideTooltipTimeout;
let suspendMasterSync = false;
const visibleMunicipios = new Set();

const municipioPolygons = {};
const municipioLabels   = {};

const visibleStates = new Set(['Coahuila', 'Durango', 'Nuevo León', 'Jalisco']);

fetch('files/kmz/MX59.json')
  .then(res => res.json())
  .then(fc => {
    const lista = document.getElementById('municipios-list');
    lista.innerHTML = '';  

    visibleStates.forEach(state => {
      municipioPolygons[state] = {};
      municipioLabels[state]   = {};
    });

    fc.features.forEach(f => {
      const state = f.properties.NAME_1;
      if (!visibleStates.has(state)) return;
      const muni = f.properties.NAME_2.trim();
      if (!muni) return;
      municipioPolygons[state][muni] = [];
      municipioLabels[state][muni]   = null;
    });

    fc.features.forEach(f => {
      const state = f.properties.NAME_1;
      if (!visibleStates.has(state)) return;
      const muni = f.properties.NAME_2.trim();
      if (!muni) return;

      const rawCoords = f.geometry.type === 'Polygon'
        ? [f.geometry.coordinates]
        : f.geometry.coordinates;
      const paths = rawCoords.map(poly =>
        poly[0].map(c => ({ lat: c[1], lng: c[0] }))
      );

      const polygon = new google.maps.Polygon({
        paths,
        fillColor:   '#000000',
        fillOpacity: fillOpacityLevel,
        strokeColor: '#ff6600',
        strokeOpacity: 1,
        strokeWeight: 2,
        clickable:   false,
        zIndex:      1
      });
      municipioPolygons[state][muni].push(polygon);

      const bounds = new google.maps.LatLngBounds();
      paths.forEach(ring => ring.forEach(pt => bounds.extend(pt)));
      const center = bounds.getCenter();
      const labelMarker = new google.maps.Marker({
        position: center,
        map:      null,
        icon: {
          path:  google.maps.SymbolPath.CIRCLE,
          scale: 0    
        },
        label: {
          text:       muni,
          color:      '#ff6600',
          fontSize:   '1px',
          fontWeight: 'bold'
        },
        clickable: false,
        zIndex:    2
      });
      municipioLabels[state][muni] = labelMarker;
    });

    const stateToMunicipios = {};
    Object.keys(municipioPolygons).forEach(state => {
      stateToMunicipios[state] = Object.keys(municipioPolygons[state]);
    });

    Object.keys(stateToMunicipios).sort().forEach(state => {
      const group = document.createElement('div');
      group.className = 'state-group';

      const header = document.createElement('div');
      header.className = 'state-header';
      header.style.display = 'flex';
      header.style.alignItems = 'center';

      const toggleIcon = document.createElement('span');
      toggleIcon.textContent = '▶';
      toggleIcon.style.cursor = 'pointer';
      toggleIcon.style.marginRight = '6px';

      const stateCb = document.createElement('input');
      stateCb.type    = 'checkbox';
      stateCb.checked = false;

      const stateLabel = document.createElement('span');
      stateLabel.textContent = state;
      stateLabel.style.marginLeft = '4px';

      header.append(toggleIcon, stateCb, stateLabel);
      group.appendChild(header);

      const muniList = document.createElement('div');
      muniList.style.paddingLeft = '20px';
      muniList.style.marginTop   = '4px';
      muniList.style.display     = 'none';

      const muniCbs = [];
      stateToMunicipios[state].sort().forEach(muni => {
        const label = document.createElement('label');
        label.style.display     = 'block';
        label.style.cursor      = 'pointer';
        label.style.userSelect  = 'none';

        const cb = document.createElement('input');
        cb.type          = 'checkbox';
        cb.dataset.state = state;
        cb.dataset.muni  = muni;
        cb.checked       = false;

        cb.addEventListener('change', () => {
          municipioPolygons[state][muni].forEach(poly =>
            poly.setMap(cb.checked ? map : null)
          );
          municipioLabels[state][muni].setMap(cb.checked ? map : null);

          if (!suspendMasterSync) {
            stateCb.checked = muniCbs.every(chk => chk.checked);
          }
        });

        label.append(cb, document.createTextNode(' ' + muni));
        muniList.appendChild(label);
        muniCbs.push(cb);
      });

      stateCb.addEventListener('change', () => {
        suspendMasterSync = true;
        muniCbs.forEach(cb => {
          cb.checked = stateCb.checked;
          cb.dispatchEvent(new Event('change'));
        });
        suspendMasterSync = false;
      });

      toggleIcon.addEventListener('click', () => {
        const collapsed = muniList.style.display === 'none';
        muniList.style.display = collapsed ? 'block' : 'none';
        toggleIcon.textContent = collapsed ? '▼' : '▶';
      });

      group.appendChild(muniList);
      lista.appendChild(group);
    });
  });

const selectAllBtn = document.getElementById('selectAllMunicipios');
const clearAllBtn  = document.getElementById('clearAllMunicipios');

selectAllBtn.addEventListener('click', () => {
  document.querySelectorAll('#municipios-list input[type="checkbox"]')
    .forEach(cb => {
      if (!cb.checked) {
        cb.checked = true;
        cb.dispatchEvent(new Event('change'));
      }
    });
});

clearAllBtn.addEventListener('click', () => {
  document.querySelectorAll('#municipios-list input[type="checkbox"]')
    .forEach(cb => {
      if (cb.checked) {
        cb.checked = false;
        cb.dispatchEvent(new Event('change'));
      }
    });
});

const toggleBtn = document.getElementById('city-toggle');
const panel     = document.getElementById('municipios-panel');

toggleBtn.addEventListener('click', () => {
  const isOpen = panel.style.display === 'block';
  if (isOpen) {
    panel.style.display = 'none';
    if (currentCircle && currentCircleData.length > 0) {
      document.getElementById('popup2').style.display = 'block';
    }
  } else {
    panel.style.display = 'block';
    document.getElementById('popup2').style.display = 'none';
  }
});

document.getElementById('municipios-close').addEventListener('click', () => {
  panel.style.display = 'none';
  if (currentCircle && currentCircleData.length > 0) {
    document.getElementById('popup2').style.display = 'block';
  }
});

playSound("sounds/start.mp3");
document.getElementById('toggle-locales-renta')
  .addEventListener('change', async e => {
    if (e.target.checked) {
      await loadCategory('localesRenta');
    }
    toggleCategory('localesRenta', e.target.checked);
    if (currentCircle) showPopup2FromCircle(currentCircle);
  });
['localesVenta','terrenosRenta','terrenosVenta'].forEach(cat => {
  const id = `toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`;
  document.getElementById(id)
    .addEventListener('change', async e => {
      if (e.target.checked) {
        await loadCategory(cat);
      }
      toggleCategory(cat, e.target.checked);
      if (currentCircle) showPopup2FromCircle(currentCircle);
    });
});
document.getElementById('toggle-all-properties')
  .addEventListener('click', async () => {
    const anyVisible = Object.values(propertyVisible).some(v => v);
    const newState   = !anyVisible;
    for (const cat of Object.keys(propertyConfig)) {
      if (newState && propertyMarkers[cat].length === 0) {
        await loadCategory(cat);
      }
      toggleCategory(cat, newState);
      document
        .getElementById(`toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`)
        .checked = newState;
    }
    if (currentCircle) showPopup2FromCircle(currentCircle);
  });
  document.getElementById("drawPolygonBtn").addEventListener("click", () => {
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";
});
document.getElementById("local-pin-toggle").addEventListener("click", () => {
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";
});

document.getElementById("exportKmzBtn").addEventListener("click", () => {
const panel = document.getElementById("export-files-panel");
if (panel) panel.style.display = "none";
});

function handleKMZFile(evt) {
  const file = evt.target.files[0];
  if (!file) return;
  file.arrayBuffer()
    .then(buf => JSZip.loadAsync(buf))
    .then(zip => {
      const kmlName = Object.keys(zip.files)
        .find(name => name.toLowerCase().endsWith('.kml'));
      return zip.file(kmlName).async('string');
    })
    .then(kmlText => {
      const kmlDoc = new DOMParser().parseFromString(kmlText, 'application/xml');
      const geojson = toGeoJSON.kml(kmlDoc);
      map.data.addGeoJson(geojson);
      map.data.setStyle({strokeColor: '#FF0000',strokeWeight: 2,fillColor: '#FF0000',fillOpacity: fillOpacityLevel,}); }) .catch(console.error);}


document.getElementById("import-files").addEventListener("click", () => {
  const panel = document.getElementById("import-files-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
document.addEventListener("click", (e) => {
  const panel = document.getElementById("import-files-panel");
  const button = document.getElementById("import-files");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
document.getElementById("draw-tools").addEventListener("click", () => {
  const panel = document.getElementById("draw-tools-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
document.addEventListener("click", (e) => {
  const panel = document.getElementById("draw-tools-panel");
  const button = document.getElementById("draw-tools");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});

document.getElementById('toggle-all-properties')
  .addEventListener('click', toggleAllProperties);
['localesRenta','localesVenta','terrenosRenta','terrenosVenta']
  .forEach(cat => {
    document.getElementById(
      `toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`
    ).addEventListener('change', e =>
      toggleCategory(cat, e.target.checked)
    );
  });
  Object.keys(propertyConfig).forEach(cat => {
  const cb = document.getElementById(`toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`);
  if (cb) cb.checked = false;
});


Object.keys(propertyConfig).forEach(cat => {
  const id = `toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`;
  const cb = document.getElementById(id);
  if (cb) cb.checked = false;
});
document.getElementById("retail-options").addEventListener("click", () => {
  const panel = document.getElementById("retail-options-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});

document.addEventListener("click", (e) => {
  const panel = document.getElementById("retail-options-panel");
  const button = document.getElementById("retail-options");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
document.getElementById("traffic-options").addEventListener("click", () => {
  const panel = document.getElementById("traffic-options-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});

document.addEventListener("click", (e) => {
  const panel = document.getElementById("traffic-options-panel");
  const button = document.getElementById("traffic-options");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});

document.getElementById("reports-options").addEventListener("click", () => {
  const panel = document.getElementById("reports-options-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
document.addEventListener("click", (e) => {
  const panel = document.getElementById("reports-options-panel");
  const button = document.getElementById("reports-options");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});

document.getElementById("settings").addEventListener("click", () => {
  const panel = document.getElementById("settings-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});

document.addEventListener("click", (e) => {
  const panel = document.getElementById("settings-panel");
  const button = document.getElementById("settings");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
const importIcon = document.getElementById("import-icon");
function updateImportIcon(isDark) {
  if (importIcon) {
    importIcon.src = isDark
      ? "https://static.wixstatic.com/media/805cf6_a527d5bf395f4bcaa236eeebc9e139b2~mv2.png" 
      : "https://static.wixstatic.com/media/805cf6_fa3277ade0834a39bed9c560c1fcc126~mv2.png";
  }
}
document.getElementById("poi-toggle-btn").addEventListener("click", () => {
  const box = document.getElementById("poi-search-box");
  box.style.display = box.style.display === "none" ? "flex" : "none";
});

document.addEventListener("click", (e) => {
  const panel = document.getElementById("poi-search-box");
  const button = document.getElementById("poi-toggle-btn");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
document.getElementById("toggle-radius-limit").addEventListener("click", () => {
  if (maxCircleRadius === 3500) {
    maxCircleRadius = 50000;
    showToast("🔓 Radius limit 50,000 m");
  } else {
    maxCircleRadius = 3500;
    showToast("🔒 Radius limit 3,500 m (original)");
  }
});
document.getElementById("poi-clear-button").addEventListener("click", () => {
  document.getElementById("poi-search-input").value = "";
  poiMarkers.forEach(marker => marker.setMap(null));
  poiMarkers = [];
});
function savePolygonToLocalStorage(polygon) {
  const stored = JSON.parse(localStorage.getItem("customPolygons") || "[]");
  const paths = polygon.getPath().getArray().map(coord => ({
    lat: coord.lat(),
    lng: coord.lng()
  }));
  const polygonData = {name: polygon.name || "", paths: paths,strokeColor: polygon.get("strokeColor"),fillColor: polygon.get("fillColor"),fillOpacity: polygon.get("fillOpacity"),clickable: polygon.get("clickable"),zIndex: polygon.get("zIndex")};
  stored.push(polygonData);
  localStorage.setItem("customPolygons", JSON.stringify(stored));
}
    document.getElementById("drawPolygonBtn").addEventListener("click", () => {
      drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
    });
    
    document.getElementById("poi-search-button").addEventListener("click", async () => {
    const query = document.getElementById("poi-search-input").value.trim();
    if (!query) {
      alert("Escribe algo para buscar!");
      return;
    }
    const results = await searchPlacesByText(query);
    renderPOIMarkers(results);
  });
  
  map.addListener("maptypeid_changed", () => {
    if (map.getMapTypeId() === "satellite") {
      map.setTilt(0);
      map.setHeading(0);
    }
  });
  initLayers();
}
function initLayers() {

trafficLayer = new google.maps.TrafficLayer();
document.getElementById("traffic-vehicles-toggle").addEventListener("click", () => {
  const isActive = !!trafficLayer.getMap();
  if (isActive) {
    trafficLayer.setMap(null);
  } else {
    deactivateAllTrafficLayers();
    trafficLayer.setMap(map);
  }
});
document.getElementById("traffic-segment-speed").addEventListener("click", () => {
  const isActive = trafficIsVisible;          
  if (isActive) {
    deactivateAllTrafficLayers();
  } else {
    deactivateAllTrafficLayers();
    drawTrafficVolumeBySegment();
  }
});

heatmap = new google.maps.visualization.HeatmapLayer({ data: [],map: null,radius: Number(document.getElementById("heatmap-radius").value),maxIntensity: 1,  	opacity: 0.5,});

function updateHeatmapFromVisibleMarkers() {
  const visibleCoords = markers
    .filter(marker => marker.getVisible())
    .map(marker => marker.getPosition());
  if (visibleCoords.length === 0) {
    heatmap.setMap(null);
    heatBtn.classList.remove("layer-active");
    return;
  }
  heatmap.setData(visibleCoords);
  if (!heatmap.getMap()) {
    heatmap.setMap(map);
    heatBtn.classList.add("layer-active");
  }
}
const heatBtn = document.getElementById("heatmap-toggle");
const heatIconOn = ` <img src="images/icons/heatmap-off.png" style="width:25px; height:25px;"alt="Heatmap OFF"/><span>Heatmap OFF</span>`;
const heatIconOff = `<img src="images/icons/heatmap.png"style="width:25px; height:25px;"alt="Heatmap ON"/><span>Heatmap ON</span>`;

heatBtn.addEventListener("click", () => {
  const isActive = Boolean(heatmap.getMap());
  if (isActive) {
    heatmap.setMap(null);
    heatBtn.classList.remove("layer-active");
    heatBtn.innerHTML = heatIconOff;
  } else {
    const metros = Number(radiusInput.value);
    heatmap.set("radius", metersToHeatmapRadius(metros));
    updateHeatmapFromVisibleMarkers();
    heatBtn.innerHTML = heatIconOn;
  }
});

const radiusInput = document.getElementById("heatmap-radius");
const radiusValue = document.getElementById("heatmap-radius-value");
heatmap.set("radius", Number(radiusInput.value));
radiusInput.addEventListener("input", () => {
  const metros = Number(radiusInput.value);
  const px = metersToHeatmapRadius(metros);
  heatmap.set("radius", px);
  radiusValue.textContent = metros;
  if (heatmap.getMap()) updateHeatmapFromVisibleMarkers();
});

/**
 * Convierte un radio en metros a píxeles para Google Maps HeatmapLayer.
 * @param {number} meters   Radio deseado, en metros.
 * @returns {number}        Radio en píxeles para el zoom y lat actual.
 */

 function metersToHeatmapRadius(meters) {
  const lat = map.getCenter().lat();
  const zoom = map.getZoom();
  const metersPerPx = 156543.03392 * Math.cos(lat * Math.PI/180) / Math.pow(2, zoom);
  return Math.round(meters / metersPerPx);
}
(function(){
  const _origSetVisible = google.maps.Marker.prototype.setVisible;
  google.maps.Marker.prototype.setVisible = function(flag) {
    _origSetVisible.call(this, flag);
    if (heatmap.getMap()) updateHeatmapFromVisibleMarkers();
  };
})();
  map.addListener("click", function (e) {
  if (!researchPinMode) return;
  selectedResearchCoords = e.latLng;
  document.getElementById("research-pin-form").style.display = "block";
});

map.addListener("zoom_changed", () => {
  if (!heatmap.getMap()) return;
  const metros = Number(radiusInput.value);
  heatmap.set("radius", metersToHeatmapRadius(metros));
  updateHeatmapFromVisibleMarkers();
});

google.maps.event.addListenerOnce(map, 'idle', () => {
  const typeControl = document.querySelector('[title="Mapa"]')?.parentNode?.parentNode;
  if (typeControl) {
    document.getElementById("menu-button").style.top = (typeControl.offsetTop + typeControl.offsetHeight + 10) + "px";
  }
  const switchEl = document.getElementById("darkModeSwitch");
  if (switchEl) {
    const storedDarkMode = localStorage.getItem("darkMode");
    
    if (storedDarkMode === "true") {
      switchEl.checked = true;
      map.setOptions({ styles: darkMapStyle });
      document.body.classList.add("dark-mode");
    }
    switchEl.addEventListener("change", function () {
      const isDark = this.checked;
      localStorage.setItem("darkMode", isDark ? "true" : "false");
      map.setOptions({ styles: isDark ? darkMapStyle : lightMapStyle });
      document.body.classList.toggle("dark-mode", isDark);
    });
  }
loadResearchPins();
 
document.getElementById("local-pin-toggle").addEventListener("click", () => {
  activatePinMode("add");
});

 function activateExpansionPinMode() {
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";
  showToast("📍 Click on the map to place the expansion pin");
  map.setOptions({ draggableCursor: "crosshair" });
  google.maps.event.clearListeners(map, "click");

  const expClickListener = map.addListener("click", function(e) {
    if (currentExpansionMarker) {
      currentExpansionMarker.setMap(null);
    }

    const expansionMarker = new google.maps.Marker({
      position: e.latLng,
      map,
      icon: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png'
    });
    currentExpansionMarker = expansionMarker;

    const iw = new google.maps.InfoWindow({
      content: `<button id="expansion-analyze-btn">Analize area</button>`
    });
    iw.open(map, expansionMarker);

google.maps.event.addListenerOnce(iw, 'domready', () => {
  document.getElementById('expansion-analyze-btn')
    .addEventListener('click', () => {
      showLoading();
      runCustomAnalysis(expansionMarker);
      iw.close();
    });
});
    google.maps.event.removeListener(expClickListener);
    map.setOptions({ draggableCursor: null });
  });
}
  document.getElementById('expansion-pin-btn')
  .addEventListener('click', activateExpansionPinMode);

document.getElementById("save-analysis-toggle").addEventListener("click", () => {
    const pins = markers.filter(m => {
      const franchiseVisible = m.getVisible() && m.__visibleByFranchise;
      const withinCircle = currentCircle
        ? google.maps.geometry.spherical.computeDistanceBetween(
            m.getPosition(),
            currentCircle.getCenter()
          ) <= currentCircle.getRadius()
        : true;
      return franchiseVisible && withinCircle;
    }).map(m => ({
      franchise:   m.franchise,
      address:     m.Address,
      category:    m.category,
      subcategory: m.subcategory,
      operations:  m.Operations,
      location:    m.location
    }));
    const rulerLine = (rulerPolyline && rulerPolyline.getPath().getLength() === 2)
      ? {
          pointA: {
            lat: rulerPolyline.getPath().getAt(0).lat(),
            lng: rulerPolyline.getPath().getAt(0).lng()
          },
          pointB: {
            lat: rulerPolyline.getPath().getAt(1).lat(),
            lng: rulerPolyline.getPath().getAt(1).lng()
          }
        }
      : null;
    const data = {
      date:      new Date().toISOString(),
      center:    currentCircle ? { lat: currentCircle.getCenter().lat(), lng: currentCircle.getCenter().lng() } : null,
      radius:    currentCircle ? currentCircle.getRadius() : null,
      pins,
      rulerLine,
      filters: {
        franchises: markers.filter(m => m.__visibleByFranchise).map(m => m.franchise),
        operations: Array.from(activeOperations),
        nse:        Array.from(activeNSEs),
        locations:  Array.from(activeLocationsFilter),
        filterPanelOpen: document.getElementById("filter-panel").classList.contains("open"),
        traffic:    Array.from(activeAvenues),
        cityBoundaries: Array.from(activeLocations)
      }
    };
    window.pendingAnalysisData = data;
    promptSaveAnalysis();
  });
document.getElementById('toolbar-toggle').addEventListener('click', function(e) {
  const bar = document.getElementById('toolbar');
  if (bar.classList.contains('toolbar-hidden')) {
	bar.classList.remove('toolbar-hidden');
	this.innerText = '▲';
	bar.style.opacity = 1;
  } else {
	bar.classList.add('toolbar-hidden');
	this.innerText = '▼';
	bar.style.opacity = 0.5;
  }
});
 
document.getElementById("ruler-toggle").addEventListener("click", () => {
  const popup = document.getElementById("ruler-popup");
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";
  if (rulerPolyline) {
              	rulerPolyline.setMap(null);
              	rulerPolyline = null;
  }
  if (tempRulerLine) {
              	tempRulerLine.setMap(null);
              	tempRulerLine = null;
  }
  if (tempDistanceLabel) {
              	tempDistanceLabel.close();
              	tempDistanceLabel = null;
  }
  rulerPoints = [];
  if (rulerListener) {
              	google.maps.event.removeListener(rulerListener);
              	rulerListener = null;
  }
  if (window._rulerMousemoveListener) {
              	google.maps.event.removeListener(window._rulerMousemoveListener);
              	window._rulerMousemoveListener = null;
  }
  showToast("Click on the map to draw a line from A to B");
  map.setOptions({ draggableCursor: "crosshair" });
  window._rulerMousemoveListener = map.addListener("mousemove", (e) => {
              	if (rulerPoints.length === 1) {
             	const path = [rulerPoints[0], e.latLng];
             	const distanceMeters = google.maps.geometry.spherical.computeDistanceBetween(
	         	rulerPoints[0], e.latLng
             	);
             	const formatted = distanceMeters >= 1000
	         	? (distanceMeters / 1000).toFixed(2) + " km"
	         	: Math.round(distanceMeters) + " m";
             	if (tempDistanceLabel) {
	         	tempDistanceLabel.setContent(formatted);
	         	tempDistanceLabel.setPosition(e.latLng);
             	} else {
	         	tempDistanceLabel = new google.maps.InfoWindow({
  	      	content: formatted,
  	      	position: e.latLng,
  	      	pixelOffset: new google.maps.Size(0, -20)
	         	});
	         	tempDistanceLabel.open(map);
             	}
             	if (tempRulerLine) {
	         	tempRulerLine.setPath(path);
             	} else {
	         	tempRulerLine = new google.maps.Polyline({
  	      	path: path,
  	      	geodesic: true,
  	      	strokeColor: rulerColor,
  	      	strokeOpacity: 0.5,
  	      	strokeWeight: 4,
  	      	map: map,
  	      	clickable: false,
  	      	zIndex: 100 
	         	});
             	}
              	}
  });
  rulerListener = map.addListener("click", (e) => {
              	rulerPoints.push(e.latLng);
              	if (rulerPoints.length === 2) {
             	if (tempDistanceLabel) tempDistanceLabel.close();
             	if (tempRulerLine) tempRulerLine.setMap(null);
             	rulerPolyline = new google.maps.Polyline({
	         	path: rulerPoints,
	         	geodesic: true,
	         	strokeColor: rulerColor,
	         	strokeOpacity: 1.0,
	         	strokeWeight: 4,
	         	map: map,
	         	zIndex: 100
             	});
             	const distance = google.maps.geometry.spherical.computeDistanceBetween(
	         	rulerPoints[0], rulerPoints[1]
             	) / 1000;
             	document.getElementById("ruler-popup-text").textContent = `Distance: ${distance.toFixed(1)} KM`;
             	popup.style.display = "block";
             	map.setOptions({ draggableCursor: null });
             	google.maps.event.removeListener(rulerListener);
             	google.maps.event.removeListener(window._rulerMousemoveListener);
             	rulerListener = null;
             	window._rulerMousemoveListener = null;
             	rulerPoints = [];
              	}
  });
});
 
loadLocalPins();
map.addListener("click", (e) => {
  if (pinMode === "add") {
              	const name = prompt("Name of your Pin:");
              	if (!name) {
             	showToast("Pin not saved.");
             	pinMode = null;
             	map.setOptions({ draggableCursor: null });
             	return;
              	}
              const position = {
             	lat: e.latLng.lat(),
             	lng: e.latLng.lng()
              	};
              	createLocalMarker(name, position);
              	localPins.push({ name, position });
              	savePinsToStorage();
              	showToast(`Pin saved: ${name}`);
              	pinMode = null;
              	map.setOptions({ draggableCursor: null });
  }
  else if (pinMode === "delete") {
              	pinMode = null;
              	map.setOptions({ draggableCursor: null });
  }
});
 
 
 
const streetView = map.getStreetView();
streetView.addListener("visible_changed", () => {
  const isVisible       = streetView.getVisible();
  const menuButton      = document.getElementById("menu-button");
  const filterPanel     = document.getElementById("filter-panel");
  const popup           = document.getElementById("popup");
  const popup2          = document.getElementById("popup2");
  const searchBox       = document.getElementById("autocomplete-container");
  const rulerPopup      = document.getElementById("ruler-popup");
  const localPinOptions = document.getElementById("local-pin-options");
  const trafficPanel    = document.getElementById("traffic-panel");
  const cityPanel       = document.getElementById("city-panel");
  const toolBar         = document.getElementById("toolbar");
  const devTool         = document.getElementById("dev-toolbar");
  if (isVisible) {
    if (menuButton)      menuButton.style.display      = "none";
    if (searchBox)       searchBox.style.display       = "none";
    if (toolBar)         toolBar.style.display         = "none";
    if (localPinOptions) localPinOptions.style.display = "none";
    wasRulerPopupVisible   = rulerPopup?.style.display   === "block";
    wasTrafficPanelVisible = trafficPanel?.style.display === "block";
    wasCityPanelVisible    = cityPanel?.style.display    === "block";
    wasPopupVisible        = popup?.style.display        === "block";
    wasPopup2Visible       = popup2?.style.display       === "block";
    wasFilterPanelOpen     = filterPanel.classList.contains("open");
    if (rulerPopup)      rulerPopup.style.display      = "none";
    if (trafficPanel)    trafficPanel.style.display    = "none";
    if (cityPanel)       cityPanel.style.display       = "none";
    if (popup)           popup.style.display           = "none";
    if (popup2)          popup2.style.display          = "none";
    filterPanel.classList.remove("open");
    if (devTool)         devTool.style.display         = "none";
  } else {
    if (menuButton)      menuButton.style.display      = "";
    if (searchBox)       searchBox.style.display       = "";
    if (toolBar)         toolBar.style.display         = "";
    if (localPinOptions) localPinOptions.style.display = "";
    if (wasRulerPopupVisible)   rulerPopup.style.display   = "block";
    if (wasTrafficPanelVisible) trafficPanel.style.display = "block";
    if (wasCityPanelVisible)    cityPanel.style.display    = "block";
    if (wasPopupVisible)        popup.style.display        = "block";
    if (wasPopup2Visible)       popup2.style.display       = "block";
    if (wasFilterPanelOpen)     filterPanel.classList.add("open");
    if (devTool)                devTool.style.display      = "";
  }
});
 
}); 
loadPins(() => { applyAllFilters();});
loadPolygons(); loadLocationPolygons(); loadTrafficData(); enableCircleDrawing(); buildNSEControl(); window.map = map;}
  
function savePinsToStorage() { localStorage.setItem("customPins", JSON.stringify(localPins));}
function loadLocalPins() {
  const stored = JSON.parse(localStorage.getItem("customPins") || "[]"); localPins = stored; stored.forEach(p => {createLocalMarker(p.name, p.position);}); }

  function createLocalMarker(name, position) {

  const marker = new google.maps.Marker({
    position,
    map,
    title: name,
    icon: {
      url: "https://static.wixstatic.com/media/805cf6_c60c413bdd6545f78929a4d92196dcd5~mv2.png",
      scaledSize: new google.maps.Size(30, 30)
    },
    zIndex: 99
  });
  marker.isLocal  = true;
  marker.pinName  = name;
  localMarkers.push(marker);
  marker.addListener("click", () => {
    if (confirm(`Delete Pin? "${name}"?`)) {
      marker.setMap(null);
      playSound("sounds/trash.mp3");
      localPins = localPins.filter(p =>
        p.name !== name ||
        p.position.lat !== position.lat ||
        p.position.lng !== position.lng
      );
      localMarkers = localMarkers.filter(m => m !== marker);
      savePinsToStorage();
      showToast(`Pin deleted: ${name}`);
      pinMode = false;
      map.setOptions({ draggableCursor: null });
    }
  });
}
 
function addGeolocationControl(map) {
 
const controlDiv = document.createElement("div");
 
map.controls[google.maps.ControlPosition.TOP_RIGHT].push(controlDiv);
 
const button = controlDiv.querySelector("button");
 
button.addEventListener("click", () => {
 
if (navigator.geolocation) {
 
navigator.geolocation.getCurrentPosition(
 
 (position) => {
 
   const pos = {lat: position.coords.latitude, lng: position.coords.longitude,};
 
   map.setCenter(pos);
 
   map.setZoom(15);
  
if (userLocationMarker) {
 
userLocationMarker.setMap(null);
 
}
  
userLocationMarker = new google.maps.Marker ( { position: pos,map: map,icon: {path: google.maps.SymbolPath.CIRCLE,scale: 8,fillColor: "#ff6600",fillOpacity: 1,strokeColor: "white",strokeWeight: 3,}});
 
 },
 
 () => {showToast("No se pudo obtener tu ubicación.");}
 
);
} 
else { showToast("Geolocalización no es soportada por tu navegador.");}
 
});
 
}
 
function loadLocationPolygons() {
  fetch(SHEET_LOCATIONS_URL)
    .then(res => res.text())
    .then(csv => {
      Papa.parse(csv, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          const container = document.getElementById("location-control-content");
          const tooltip = document.getElementById("polygon-tooltip");
          container.innerHTML = "";
          const checkboxes = {};
          results.data.forEach(row => {
            const wkt = row.WKT?.trim();
            const city = row.location?.trim();
            const perimeter = row.PERIMETER?.trim();
            if (!wkt || !city) return;
            try {
              const paths = parseWKTPolygon(wkt);
              const polygon = new google.maps.Polygon({
                paths: paths,
                strokeColor: "#ff6600",
                strokeOpacity: 0.8,
                strokeWeight: 8,
                fillColor: "#888888",
                fillOpacity: fillOpacityLevel,
                zIndex: 98,
                map: null,
                clickable: false
              });
              polygon.customCity = city;
              polygon.customPerimeter = perimeter;
  polygon.addListener("click", (e) => {
  tooltip.innerHTML = `<strong>${polygon.customCity}</strong><br>Área: ${polygon.customPerimeter} km²`;
  tooltip.style.display = "block";
  const point = e.pixel || fromLatLngToContainerPixel(map, e.latLng);
  tooltip.style.left = `${point.x + 10}px`;
  tooltip.style.top = `${point.y + 10}px`;
  if (tooltipTimeout) clearTimeout(tooltipTimeout);
  tooltipTimeout = setTimeout(() => {
    tooltip.style.display = "none";
  }, 2000);
});
              map.addListener("click", () => {
                tooltip.style.display = "none";
              });
              if (!locationPolygons[city]) locationPolygons[city] = [];
              locationPolygons[city].push(polygon);
            } catch (e) {
              console.warn("Error al procesar ciudad:", e);
            }
          });
          const cities = Object.keys(locationPolygons).sort();
          cities.forEach(city => {
            const label = document.createElement("label");
            label.style.display = "block";
            label.style.marginTop = "12px";
            label.style.marginBottom = "12px";
            label.style.fontSize = "13px";
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = false;
            checkboxes[city] = checkbox;
            checkbox.addEventListener("change", () => {
              if (checkbox.checked) {
                activeLocations.add(city);
                locationPolygons[city].forEach(poly => poly.setMap(map));
              } else {
                activeLocations.delete(city);
                locationPolygons[city].forEach(poly => poly.setMap(null));
              }
            });
            label.appendChild(checkbox);
            label.append(" " + city);
            container.appendChild(label);
          });
          document.getElementById("selectAllLocations").onclick = () => {
            cities.forEach(city => {
              checkboxes[city].checked = true;
              activeLocations.add(city);
              locationPolygons[city].forEach(poly => poly.setMap(map));
            });
          };
          document.getElementById("clearAllLocations").onclick = () => {
            cities.forEach(city => {
              checkboxes[city].checked = false;
              activeLocations.delete(city);
              locationPolygons[city].forEach(poly => poly.setMap(null));
            });
          };
        }
      });
    });
}
 
 
function fromLatLngToContainerPixel(map, latLng) {
  const scale = Math.pow(2, map.getZoom());
  const nw = new google.maps.LatLng(
    map.getBounds().getNorthEast().lat(),
    map.getBounds().getSouthWest().lng()
  );
  const worldCoordinateNW = map.getProjection().fromLatLngToPoint(nw);
  const worldCoordinate = map.getProjection().fromLatLngToPoint(latLng);
  return {
    x: Math.floor((worldCoordinate.x - worldCoordinateNW.x) * scale),
    y: Math.floor((worldCoordinate.y - worldCoordinateNW.y) * scale)
  };
}

 
function toggleMenu() {
  playSound("sounds/open.mp3");
 
const panel = document.getElementById("filter-panel");
const popup1 = document.getElementById("popup");
const menuButton = document.getElementById("menu-button");
panel.classList.toggle("open");
popup1.classList.toggle("shifted", panel.classList.contains("open"));
 
 
}
 
 
function loadPins(callback) {
  const visibleStates = ["Coahuila", "Nuevo León", "Tamaulipas", "Durango","Jalisco","Aguascalientes","Guanajuato","Baja California"];
  let totalMarkersAdded = 0;

  function processCSVData(csvText, label) {
    let count = 0;

    Papa.parse(csvText, {
      header: true,
      skipEmptyLines: true,
      complete: results => {
        results.data.forEach(row => {
          const lat = parseFloat(row.Latitude);
          const lng = parseFloat(row.Longitude);
          if (isNaN(lat) || isNaN(lng)) return;

          const state = row.State?.trim();
          if (!visibleStates.includes(state)) return;

          const marker = new google.maps.Marker({
            position: { lat, lng },
            map,
            zIndex: 99,
            visible: false,
            clickable: true,
            title: `${row.Address?.trim() || 'Sin dirección'}`,
            icon: {
              url: row.Icon || "https://maps.google.com/mapfiles/ms/icons/yellow-dot.png",
              scaledSize: new google.maps.Size(30, 32)
            }
          });

          const originalSize = new google.maps.Size(30, 32);
          const hoverSize = new google.maps.Size(45, 48);

          marker.addListener("mouseover", () => {
            marker.setIcon({
              url: row.Icon,
              scaledSize: hoverSize,
            });
          });

          marker.addListener("mouseout", () => {
            marker.setIcon({
              url: row.Icon,
              scaledSize: originalSize
            });
          });

          marker.category     = row.Category?.trim()     || "Uncategorized";
          marker.subcategory  = row.Subcategory?.trim()  || "Uncategorized";
          marker.franchise    = row.Franchise?.trim()    || "Unnamed";
          marker.Operations   = row.Operations?.trim()   || "Unspecified";
          marker.Address      = row.Address?.trim()      || "No address";
          marker.location     = row.Location?.trim()     || "No address";
          marker.state        = row.State?.trim()        || "No address";
          marker.webpage      = row.Webpage?.trim()      || "No address";
          marker.__visibleByFranchise = false;

          markers.push(marker);
          totalMarkersAdded++;
          count++;

          marker.addListener('click', () => {
            if (infoWindow) infoWindow.close();
            const hasAnalysis = analysisCircles.length > 0;

            const tpl = `
              <div style="font-size:12px;">
                <strong>${marker.franchise}</strong><br>
                ${marker.Address}<br>
                <button id="analyze-btn" style="margin-top:8px;">
                  ${hasAnalysis ? 'Redo Ananlysis' : 'Run Analysis'}
                </button>
                ${hasAnalysis ? '<button id="clear-analysis-btn" style="margin-left:8px;">Clear Analysis</button>' : ''}
                <button id="set-base-btn" style="margin-top:8px; margin-left:4px;">
                  Set as base
                </button>
              </div>`;

            infoWindow = new google.maps.InfoWindow({ content: tpl });
            infoWindow.open(map, marker);

            google.maps.event.addListenerOnce(infoWindow, 'domready', () => {
              document.getElementById('analyze-btn')
                .addEventListener('click', () => {
                  performAnalysis(marker);
                  infoWindow.close();
                });

              document.getElementById('set-base-btn')
                .addEventListener('click', () => {
                  setBaseFranchise(marker);
                  infoWindow.close();
                });

              const clearBtn = document.getElementById('clear-analysis-btn');
              if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                  analysisCircles.forEach(c => c.setMap(null));
                  analysisMarkers.forEach(m => m.setMap(null));

                  if (currentExpansionMarker) {
                    currentExpansionMarker.setMap(null);
                    currentExpansionMarker = null;
                  }

                  analysisCircles = [];
                  analysisMarkers = [];
                  infoWindow.close();
                });
              }
            });
          });
        });
        console.log(`Markers found in ${label}:`, count);
      }
    });
  }

  Promise.all([
    fetch(SHEET_PINS1_URL).then(res => res.text()),
    fetch(SHEET_PINS2_URL).then(res => res.text())
  ])
  .then(([csv1, csv2]) => {
    processCSVData(csv1, "SHEET_PINS1");
    processCSVData(csv2, "SHEET_PINS2");

    buildFilterPanelGlobal();
    buildOperationsControl();
    populateSearchIndex();
    setupAutocomplete();
    buildLocationFilter();

    if (typeof callback === "function") callback();
  })
  .catch(err => {
    console.error("❌ Error cargando los CSV de pines:", err);
  });
}

 
 
 
 
function closeRulerPopup() { document.getElementById("ruler-popup").style.display = "none"; if (rulerPolyline) { rulerPolyline.setMap(null); rulerPolyline = null; } }
 
function loadPolygons() {

  fetch(SHEET_NSE_URL)
    .then(res => res.text())
    .then(csv => {
      Papa.parse(csv, {
        header: true,
        skipEmptyLines: true,
        transformHeader: h => h.trim(),   
        complete: results => {
          results.data.forEach(row => {
            const ambito = row.Ambito?.trim();
            if (ambito !== 'Urbana') return;

            const wkt = row.WKT?.trim();
            const nse = row.NSE?.trim();
            const pob = parseInt(row.POB, 10) || 0;
            const viv = parseInt(row.VIV, 10) || 0;
            if (!wkt || !nse || !(nse in nseColors)) return;

            try {
              const paths = parseWKTPolygon(wkt);
              const polygon = new google.maps.Polygon({
                paths,
                strokeColor:   nseColors[nse],
                strokeOpacity: 0.35,
                strokeWeight:  1,
                fillColor:     nseColors[nse],
                fillOpacity:   0.3,
                map:           null,
                clickable:     false,
                zIndex:        2,
              });

              polygon.customData = { NSE: nse, POB: pob, VIV: viv };
              polygons.push(polygon);

              if (!nsePolygons[nse]) nsePolygons[nse] = [];
              nsePolygons[nse].push(polygon);

            } catch (e) {
              console.warn("Error al procesar WKT:", e);
            }
          });
    
         window.allNsePolygons = Object.values(nsePolygons).flat();
window.allNsePolygons.forEach(poly => {
  const bounds = new google.maps.LatLngBounds();
  poly.getPath().getArray().forEach(pt => bounds.extend(pt));
  poly._bounds = bounds;
});

        }
      });
    })
    .catch(err => console.error("Error al cargar CSV:", err));
}

function parseWKTPolygon(wkt) {return wkt.replace(/^POLYGON\s*\(\(\s*/i, '').replace(/\)\)\s*$/, '').split(/,\s*/).map(pair => {const [lng, lat] = pair.split(/\s+/).map(Number);return { lat, lng };});}

function parseWKTPolygon(wkt) { return wkt.replace("POLYGON ((", "").replace("))", "") .split(", ").map(coord => { const [lng, lat] = coord.split(" ").map(Number); return { lat, lng }; }); }
 
function parseWKTLine(wkt) { return wkt.replace("LINESTRING (", "").replace(")", "") .split(",").map(coord => { const [lng, lat] = coord.trim().split(" ").map(Number); return { lat, lng }; }); }
 

function buildGroupedAvenueControl(data) {
  const container = document.getElementById("avenue-control-content");
  container.innerHTML = "";

  Object.keys(data).sort().forEach(state => {
    const stateDetails = document.createElement("details");
    stateDetails.className = "dropdown";
    stateDetails.open = false;

    const stateSummary = document.createElement("summary");
    stateSummary.style.display = "flex";
    stateSummary.style.alignItems = "center";
    stateSummary.style.gap = "6px";

    const stateCheckbox = document.createElement("input");
    stateCheckbox.type = "checkbox";
    stateCheckbox.className = "summary-checkbox";
    stateCheckbox.value = state;

    const allStatePolys = [];
    Object.values(data[state]).forEach(typeObj => {
      Object.values(typeObj).forEach(locOrAvenues => {
        if (Array.isArray(locOrAvenues)) {
          allStatePolys.push(...locOrAvenues);
        } else {
          Object.values(locOrAvenues).forEach(arr => allStatePolys.push(...arr));
        }
      });
    });
    stateCheckbox.checked = allStatePolys.length > 0 &&
                           allStatePolys.every(poly => activeAvenues.has(poly.customAvenue));

    const stateLabel = document.createElement("span");
    stateLabel.textContent = state;
    stateLabel.className = "category-label";

    stateSummary.append(stateCheckbox, stateLabel);
    stateDetails.append(stateSummary);

    const updateStateCheckbox = () => {
      const childCbs = stateDetails.querySelectorAll("input[type=checkbox]:not(.summary-checkbox)");
      const checkedCount = Array.from(childCbs).filter(cb => cb.checked).length;
      stateCheckbox.checked = childCbs.length > 0 && checkedCount === childCbs.length;
    };
    stateCheckbox.addEventListener("change", () => {
      const checked = stateCheckbox.checked;
      stateDetails
        .querySelectorAll("input[type=checkbox]:not(.summary-checkbox)")
        .forEach(cb => {
          cb.checked = checked;
          cb.dispatchEvent(new Event("change"));
        });
    });

    Object.keys(data[state]).sort().forEach(type => {
      const typeDetails = document.createElement("details");
      typeDetails.className = "dropdown details-subcategory";
      typeDetails.open = false;

      const typeSummary = document.createElement("summary");
      typeSummary.style.display = "flex";
      typeSummary.style.alignItems = "center";
      typeSummary.style.gap = "10px";

      const typeCheckbox = document.createElement("input");
      typeCheckbox.type = "checkbox";
      typeCheckbox.className = "summary-checkbox";
      typeCheckbox.value = type;

      const allTypePolys = [];
      if (type.toLowerCase() === "urban train") {
        Object.values(data[state][type]).forEach(arr => allTypePolys.push(...arr));
      } else {
        Object.values(data[state][type]).forEach(locObj =>
          Object.values(locObj).forEach(arr => allTypePolys.push(...arr))
        );
      }
      typeCheckbox.checked = allTypePolys.length > 0 &&
                             allTypePolys.every(poly => activeAvenues.has(poly.customAvenue));

      const typeLabel = document.createElement("span");
      typeLabel.textContent = type;
      typeLabel.className = "subcategory-label";

      if (type.toLowerCase() === "urban train" ||
    type.toLowerCase() === "main thoroughfares") {
  typeLabel.style.color = "gray";
}

      typeSummary.append(typeCheckbox, typeLabel);
      typeDetails.append(typeSummary);

      const updateTypeCheckbox = () => {
        const childCbs = typeDetails.querySelectorAll("input[type=checkbox]:not(.summary-checkbox)");
        const checkedCount = Array.from(childCbs).filter(cb => cb.checked).length;
        typeCheckbox.checked = childCbs.length > 0 && checkedCount === childCbs.length;
        updateStateCheckbox();
      };
      typeCheckbox.addEventListener("change", () => {
        const checked = typeCheckbox.checked;
        typeDetails
          .querySelectorAll("input[type=checkbox]:not(.summary-checkbox)")
          .forEach(cb => {
            cb.checked = checked;
            cb.dispatchEvent(new Event("change"));
          });
      });

      if (type.toLowerCase() === "urban train") {
        Object.keys(data[state][type]).sort().forEach(avenue => {
          const label = document.createElement("label");
          label.style.marginLeft = "15px";
          label.style.fontSize = "12px";
          label.style.display = "block";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.value = avenue;
          checkbox.checked = data[state][type][avenue]
            .every(poly => activeAvenues.has(poly.customAvenue));

          checkbox.addEventListener("change", () => {
            data[state][type][avenue].forEach(poly => {
              poly.setMap(checkbox.checked ? map : null);
              if (checkbox.checked) activeAvenues.add(poly.customAvenue);
              else activeAvenues.delete(poly.customAvenue);
            });
            updateTypeCheckbox();
          });

          label.append(checkbox, document.createTextNode(" " + avenue));
          typeDetails.append(label);
        });

      } else {
        Object.keys(data[state][type]).sort().forEach(location => {
          const locationDetails = document.createElement("details");
          locationDetails.className = "dropdown";
          locationDetails.open = false;

          const locationSummary = document.createElement("summary");
          locationSummary.style.display = "flex";
          locationSummary.style.alignItems = "center";
          locationSummary.style.gap = "20px";

          const locationCheckbox = document.createElement("input");
          locationCheckbox.type = "checkbox";
          locationCheckbox.className = "summary-checkbox";
          locationCheckbox.value = location;

          const allLocationPolys = Object.values(data[state][type][location]).flat();
          locationCheckbox.checked = allLocationPolys.length > 0 &&
                                     allLocationPolys.every(poly => activeAvenues.has(poly.customAvenue));

          const locationLabel = document.createElement("span");
          locationLabel.textContent = location;
          locationLabel.className = "subcategory-label";

          locationSummary.append(locationCheckbox, locationLabel);
          locationDetails.append(locationSummary);

          const updateLocationCheckbox = () => {
            const cbs = locationDetails.querySelectorAll("input[type=checkbox]:not(.summary-checkbox)");
            const count = Array.from(cbs).filter(cb => cb.checked).length;
            locationCheckbox.checked = cbs.length > 0 && count === cbs.length;
            updateTypeCheckbox();
          };
          locationCheckbox.addEventListener("change", () => {
            const checked = locationCheckbox.checked;
            locationDetails
              .querySelectorAll("input[type=checkbox]:not(.summary-checkbox)")
              .forEach(cb => {
                cb.checked = checked;
                cb.dispatchEvent(new Event("change"));
              });
          });

          Object.keys(data[state][type][location]).sort().forEach(avenue => {
            const label = document.createElement("label");
            label.style.marginLeft = "20px";
            label.style.fontSize = "12px";
            label.style.display = "block";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = avenue;
            checkbox.checked = data[state][type][location][avenue]
              .every(poly => activeAvenues.has(poly.customAvenue));

            checkbox.addEventListener("change", () => {
              data[state][type][location][avenue].forEach(poly => {
                poly.setMap(checkbox.checked ? map : null);
                if (checkbox.checked) activeAvenues.add(poly.customAvenue);
                else activeAvenues.delete(poly.customAvenue);
              });
              updateLocationCheckbox();
            });

            label.append(checkbox, document.createTextNode(" " + avenue));
            locationDetails.append(label);
          });

          typeDetails.append(locationDetails);
        });
      }

      stateDetails.append(typeDetails);
    });

    container.append(stateDetails);
  });
}

</script>
 
<script>
function enableCircleDrawing() {
  const manager = new google.maps.drawing.DrawingManager({
    drawingMode: null,
    drawingControl: false,
    circleOptions: {
      fillColor: circleColor,
      fillOpacity: fillOpacityLevel,
      strokeColor: "#FF0000",
      strokeWeight: 7.5,
      clickable: false,
      editable: false,
      zIndex: 100
    }
  });
  manager.setMap(map);
  google.maps.event.addListener(manager, 'circlecomplete', circle => {
    if (currentCircle) currentCircle.setMap(null);
    currentCircle = circle;
    circle.setRadius(Math.min(circle.getRadius(), maxCircleRadius));
    currentCircleData = markers.filter(marker => {
      const dist = google.maps.geometry.spherical
        .computeDistanceBetween(circle.getCenter(), marker.getPosition());
      return dist <= circle.getRadius() && marker.getVisible();
    });
    let foundNSE = false;
    for (const nse of activeNSEs) {
      const polys = nsePolygons[nse] || [];
      for (const poly of polys) {
        for (const point of poly.getPath().getArray()) {
          if (google.maps.geometry.spherical
            .computeDistanceBetween(circle.getCenter(), point)
            <= circle.getRadius()) {
            foundNSE = true;
            break;
          }
        }
        if (foundNSE) break;
      }
      if (foundNSE) break;
    }
    const allProps = Object.values(propertyMarkers)
  .reduce((acc, arr) => acc.concat(arr), []);  
const propsInCircle = allProps.filter(o => {
  const pos = o.getPosition?.() || o.getCenter?.();
  if (!pos) return false;
  return google.maps.geometry.spherical
    .computeDistanceBetween(circle.getCenter(), pos)
    <= circle.getRadius();
});

    if (currentCircleData.length === 0 && !foundNSE && propsInCircle.length === 0) {
      circle.setMap(null);
      currentCircle = null;
      playSound("sounds/circle_empty.mp3");
      showToast("The radius is empty");
    } else {
      showPopup2FromCircle(circle);
      playSound("sounds/popup.mp3");
    }
    manager.setDrawingMode(null);
  });
  document.getElementById("circle-toggle").addEventListener("click", () => {
    const panel = document.getElementById("draw-tools-panel");
    if (panel) panel.style.display = "none";
    manager.setDrawingMode(google.maps.drawing.OverlayType.CIRCLE);
  });
}
 
function buildNSEControl() {
 
const container = document.getElementById("nse-control-content");
 
container.innerHTML = "";
 
const group = document.createElement("div");
 
group.className = "nse-checkbox-group";
 
const checkboxes = {};
 
for (const nse of Object.keys(nseColors)) {
 
const label = document.createElement("label");
 
const checkbox = document.createElement("input");
 
checkbox.type = "checkbox";
 
checkbox.checked = false;
 
checkboxes[nse] = checkbox;
 
checkbox.onchange = () => {
 
if (checkbox.checked) {
 
activeNSEs.add(nse);
 
if (nsePolygons[nse]) nsePolygons[nse].forEach(poly => poly.setMap(map));
 
} else {
 
activeNSEs.delete(nse);
 
if (nsePolygons[nse]) nsePolygons[nse].forEach(poly => poly.setMap(null));
 
}
 
updatePopupIfCircleExists();
 
};
 
label.appendChild(checkbox);
 
const badge = document.createElement("span");
 
badge.textContent = " " + nse;
 
badge.style.backgroundColor = nseColors[nse];
 
badge.style.color = "white";
 
badge.style.padding = "2px 6px";
 
badge.style.marginLeft = "6px";
 
badge.style.borderRadius = "4px";
 
badge.style.fontSize = "12px";
 
badge.style.fontWeight = "bold";
 
badge.style.display = "inline-block";
 
label.appendChild(badge);
 
group.appendChild(label);
 
}
 
container.appendChild(group);
 
document.getElementById("selectAllNSE").onclick = () => {
 
Object.keys(checkboxes).forEach(nse => {
 
checkboxes[nse].checked = true;
 
activeNSEs.add(nse);
 
if (nsePolygons[nse]) nsePolygons[nse].forEach(poly => poly.setMap(map));
 
});
 
updatePopupIfCircleExists();
 
};
 
document.getElementById("clearAllNSE").onclick = () => {
 
const checkedCount = Object.values(checkboxes).filter(cb => cb.checked).length;
Object.keys(checkboxes).forEach(nse => {
checkboxes[nse].checked = false;
activeNSEs.delete(nse);
if (nsePolygons[nse]) nsePolygons[nse].forEach(poly => poly.setMap(null));
});
updatePopupIfCircleExists();
};
}


function buildLocationFilter() {
  const container = document.getElementById("location-filter-content");
  container.innerHTML = "";
  container.style.marginTop = "12px";

  const checkboxes = {};
  const stateCheckboxes = {};
  const states = {};

  markers.forEach(marker => {
    if (!states[marker.state]) {
      states[marker.state] = new Set();
    }
    states[marker.state].add(marker.location);
  });

  Object.entries(states).forEach(([state, locationsSet]) => {
    const wrapper = document.createElement("div");
    wrapper.style.marginBottom = "8px";
    const stateHeader = document.createElement("div");
    stateHeader.style.display = "flex";
    stateHeader.style.alignItems = "center";
    stateHeader.style.justifyContent = "space-between";
    stateHeader.style.cursor = "pointer";
    stateHeader.style.fontSize = "12px";
    stateHeader.style.color = "#f60";
    stateHeader.style.fontWeight = "bold";

    const stateLabelWrapper = document.createElement("div");
    stateLabelWrapper.style.display = "flex";
    stateLabelWrapper.style.alignItems = "center";
    stateLabelWrapper.style.gap = "6px";

    const stateCheckbox = document.createElement("input");
    stateCheckbox.type = "checkbox";
    stateCheckbox.value = state;
    stateCheckbox.classList.add("state-checkbox");
    const allCitiesSelected = [...locationsSet].every(loc =>
      activeLocationsFilter.has(loc)
    );
    stateCheckbox.checked = allCitiesSelected;
    stateCheckboxes[state] = stateCheckbox;

    const stateLabel = document.createElement("span");
    stateLabel.textContent = state;

    stateLabelWrapper.append(stateCheckbox, stateLabel);

    const arrow = document.createElement("span");
    arrow.textContent = "▶"; 

    const locationsContainer = document.createElement("div");
    locationsContainer.style.marginLeft = "24px";
    locationsContainer.style.display = "none";
    const groupClass = `group-${state.replace(/\s+/g, "-")}`;
    locationsContainer.classList.add(groupClass);

    stateHeader.onclick = () => {
      const isVisible = locationsContainer.style.display !== "none";
      locationsContainer.style.display = isVisible ? "none" : "block";
      arrow.textContent = isVisible ? "▶" : "▼";
    };
    stateCheckbox.onclick = e => e.stopPropagation();

    stateCheckbox.onchange = () => {
      const checked = stateCheckbox.checked;
      locationsSet.forEach(loc => {
        checkboxes[loc].checked = checked;
        if (checked) activeLocationsFilter.add(loc);
        else activeLocationsFilter.delete(loc);
      });
      applyAllFilters();
    };

    stateHeader.append(stateLabelWrapper, arrow);
    wrapper.append(stateHeader, locationsContainer);

    [...locationsSet].sort().forEach(loc => {
      const label = document.createElement("label");
      label.style.display = "block";
      label.style.margin = "6px 0";
      label.style.fontSize = "12px";
      label.style.color = "#000";
      label.style.fontWeight = "500";

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = loc;
      checkbox.checked = activeLocationsFilter.has(loc);
      checkboxes[loc] = checkbox;

      checkbox.onchange = () => {
        if (checkbox.checked) {
          activeLocationsFilter.add(loc);
        } else {
          activeLocationsFilter.delete(loc);
        }
        const allChecked = [...locationsSet].every(l => checkboxes[l].checked);
        stateCheckbox.checked = allChecked;
        applyAllFilters();
      };

      label.append(checkbox, document.createTextNode(" " + loc));
      locationsContainer.appendChild(label);
    });

    container.appendChild(wrapper);
  });

  document.getElementById("selectAllLocationsFilter").onclick = () => {
    Object.keys(checkboxes).forEach(loc => {
      checkboxes[loc].checked = true;
      activeLocationsFilter.add(loc);
    });
    Object.values(stateCheckboxes).forEach(cb => cb.checked = true);
    applyAllFilters();
  };

  document.getElementById("clearAllLocationsFilter").onclick = () => {
    Object.keys(checkboxes).forEach(loc => {
      checkboxes[loc].checked = false;
      activeLocationsFilter.delete(loc);
    });
    Object.values(stateCheckboxes).forEach(cb => cb.checked = false);
    applyAllFilters();
  };
}

function buildOperationsControl() {
 
const container = document.getElementById("operations-control-content");
 
container.innerHTML = "";
 
const checkboxes = {};
 
const operationsFound = new Set();
 
markers.forEach(marker => {
 
const op = marker.Operations?.trim() || "Sin operación";
 
operationsFound.add(op);
 
});
 
 
 
 
 
const group = document.createElement("div");
 
group.className = "operations-checkbox-group";
 
Array.from(operationsFound).sort((a, b) => a.localeCompare(b)).forEach(op => {
 
const label = document.createElement("label");
 
const checkbox = document.createElement("input");
 
checkbox.type = "checkbox";
 
checkbox.checked = true;
 
checkboxes[op] = checkbox;
 
checkbox.onchange = () => {
 
if (!checkbox.checked) {
 
const remaining = Array.from(container.querySelectorAll('input[type="checkbox"]'))
 
.filter(cb => cb !== checkbox && cb.checked);
 
if (remaining.length === 0) {
 
checkbox.checked = true;
 
setTimeout(() => {
 
  showToast("There must be at least one operation selected.");
 
}, 10);
 
return;
 
}
 
activeOperations.delete(op);
 
} else {
 
activeOperations.add(op);
 
}
 
updateOperationsFilter();
 
};
 
label.appendChild(checkbox);
 
label.appendChild(document.createTextNode(" " + op));
 
group.appendChild(label);
 
});
 
container.appendChild(group);
 
document.getElementById("selectAllOperations").onclick = () => {
 
Object.keys(checkboxes).forEach(op => {
 
checkboxes[op].checked = true;
 
activeOperations.add(op);
 
});
 
updateOperationsFilter();
 
};
 
}
 
function updateOperationsFilter() { activeOperations = new Set(); document.querySelectorAll("#operations-control-content input[type=checkbox]").forEach(input => {if (input.checked) {const opLabel = input.nextSibling?.textContent?.trim();if (opLabel) activeOperations.add(opLabel);}
 
});
 
applyAllFilters();
 
updatePopupIfCircleExists();
 
}
 
 
</script>
 
<script>
 
function buildFilterPanelGlobal() {
 
const panel = document.getElementById("pin-control-content");
 
const openDetails = new Set();
 
panel.querySelectorAll("details").forEach(d => {
 
if (d.open) {
 
const label = d.querySelector("summary span")?.textContent;
 
if (label) openDetails.add(label);
 
}
 
});
 
panel.innerHTML = "";
 
const grouped = {};
 
markers.forEach(marker => {
 
const cat = marker.category;
 
const sub = marker.subcategory;
 
const fra = marker.franchise;
 
if (!grouped[cat]) grouped[cat] = {};
 
if (!grouped[cat][sub]) grouped[cat][sub] = {};
 
if (!grouped[cat][sub][fra]) grouped[cat][sub][fra] = [];
 
grouped[cat][sub][fra].push(marker);
 
});
 
const orderedCategories = Object.keys(grouped).sort((a, b) => a.localeCompare(b));
 
for (const cat of orderedCategories) {
 
const catDetails = document.createElement("details");
 
catDetails.className = "dropdown";
 
catDetails.open = openDetails.has(cat);
 
const catSummary = document.createElement("summary");
 
catSummary.innerHTML = "";
 
catSummary.style.display = "flex";
 
catSummary.style.alignItems = "center";
 
catSummary.style.gap = "6px";
 
 
 
const catCheckbox = document.createElement("input");
 
catCheckbox.type = "checkbox";
 
catCheckbox.className = "summary-checkbox";
 
catCheckbox.checked = isCategoryVisible(grouped[cat]);
 
catCheckbox.onchange = () => {
 
const visible = catCheckbox.checked;
 
for (const sub in grouped[cat]) {
 
for (const fra in grouped[cat][sub]) {
 
grouped[cat][sub][fra].forEach(m => {
 
m.__visibleByFranchise = visible;
 
});
 
}
 
}
 
applyAllFilters();
 
buildFilterPanelGlobal();
 
};
 
const catLabel = document.createElement("span");
 
catLabel.textContent = cat;
 
catLabel.className = "category-label";
 
catSummary.appendChild(catCheckbox);
 
catSummary.appendChild(catLabel);
 
catDetails.appendChild(catSummary);
 
const sortedSubcategories = Object.keys(grouped[cat]).sort((a, b) => a.localeCompare(b));
 
for (const sub of sortedSubcategories) {
 
const subDetails = document.createElement("details");
 
subDetails.className = "dropdown details-subcategory";
 
subDetails.open = openDetails.has(sub);
 
const subSummary = document.createElement("summary");
 
subSummary.innerHTML = "";
 
subSummary.style.display = "flex";
 
subSummary.style.alignItems = "center";
 
subSummary.style.gap = "6px";
 
const subCheckbox = document.createElement("input");
 
subCheckbox.type = "checkbox";
 
subCheckbox.className = "summary-checkbox";
 
subCheckbox.checked = isSubcategoryVisible(grouped[cat][sub]);
 
subCheckbox.onchange = () => {
 
const visible = subCheckbox.checked;
 
for (const fra in grouped[cat][sub]) {
 
grouped[cat][sub][fra].forEach(m => {
 
m.__visibleByFranchise = visible;
 
});
 
}
 
applyAllFilters();
 
buildFilterPanelGlobal();
 
};
 
const subLabel = document.createElement("span");
 
subLabel.textContent = sub;
 
subLabel.className = "subcategory-label";
 
subSummary.appendChild(subCheckbox);
 
subSummary.appendChild(subLabel);
 
subDetails.appendChild(subSummary);
 
const sortedFranchises = Object.keys(grouped[cat][sub]).sort((a, b) => a.localeCompare(b));
 
for (const fra of sortedFranchises) {
 
const active = grouped[cat][sub][fra][0].__visibleByFranchise || false;
 
const button = document.createElement("div");
 
button.className = "toggle-btn";
 
if (active) button.classList.add("active");
 
button.textContent = `${fra}`;
 

button.onclick = (e) => {
  e.stopPropagation();
  const isNowActive = button.classList.toggle("active");
  grouped[cat][sub][fra].forEach(m => {
    m.__visibleByFranchise = isNowActive;
  });
  applyAllFilters();
  buildFilterPanelGlobal();

  if (currentAnalyzedFranchise === fra && !isNowActive) {
    analysisCircles.forEach(c => c.setMap(null));
    analysisMarkers.forEach(m => m.setMap(null));
    analysisCircles = [];
    analysisMarkers = [];

    if (typeof closePopup2 === 'function') {
      closePopup2();
    }

    currentAnalyzedFranchise = null;
  }
};

subDetails.appendChild(button);
 
}
 
catDetails.appendChild(subDetails);
 
}
 
panel.appendChild(catDetails);}}
 
function isCategoryVisible(categoryGroup) {
 
for (const sub in categoryGroup) {
 
if (!isSubcategoryVisible(categoryGroup[sub])) return false;
 
}
 
return true;
 
}
 
function isSubcategoryVisible(subGroup) {
 
for (const fra in subGroup) {
 
if (!subGroup[fra][0].getVisible()) return false;
 
}
 
return true;
 
}
 
function selectAllMarkers() {
 
markers.forEach(marker => {
 
marker.__visibleByFranchise = true;
 
});
 
applyAllFilters();
 
buildFilterPanelGlobal();
 
}
 
function deselectAllMarkers() {
 
markers.forEach(marker => {
 
marker.__visibleByFranchise = false;
 
});
 
applyAllFilters();
 
buildFilterPanelGlobal();
 
}
 
function updatePopupIfCircleExists() {
 
if (currentCircle) {
 
currentCircleData = markers.filter(marker => {
 
const dist = google.maps.geometry.spherical.computeDistanceBetween(currentCircle.getCenter(), marker.getPosition());
 
return dist <= currentCircle.getRadius() && marker.getVisible();
 
});
 
showPopup2FromCircle(currentCircle);
 
}
 
}
 
function downloadExcel() {
  if (!currentCircle) {
    showToast("Dibuja un círculo para descargar datos.");
    return;
  }
  const center = currentCircle.getCenter();
  const radius = currentCircle.getRadius();
  const franchiseData = currentCircleData.map(marker => ({
    Category:    marker.category,
    Subcategory: marker.subcategory,
    Franchise:   marker.franchise,
    Operations:  marker.Operations || "Sin operación",
    Address:     marker.Address   || "Sin dirección"
  }));
  if (franchiseData.length === 0) {
    showToast("No hay franquicias dentro del círculo.");
    return;
  }
  const ws1 = XLSX.utils.json_to_sheet(franchiseData);
  function makePropSheet(key, sheetName) {
    const rows = (propertyMarkers[key] || [])
      .filter(m => {
        const pos = m.getPosition?.() || m.getCenter?.();
        return pos &&
          google.maps.geometry.spherical.computeDistanceBetween(pos, center) <= radius;
      })
      .map(m => {
        const p = m._props || {};
        const nombre = p.título 
                      || p.Nombre
                      || p.nombre
                      || p.titulo
                      || p.Titulo
                      || p.name
                      || p.Name
                      || m.Address
                      || "Sin título";
        return {
          Property: nombre,
          Ticket:   p.precio     ?? "N/A",
          Area:     p.superficie ?? "N/A"
        };
      });
    return {
      sheetName,
      rows,
      sheet: XLSX.utils.json_to_sheet(rows)
    };
  }
  const propSheets = [ makePropSheet('localesRenta',   'Spaces_Lease'), makePropSheet('localesVenta',   'Spaces_Sale'), makePropSheet('terrenosRenta',  'Land_Lease'), makePropSheet('terrenosVenta',  'Land_Sale')];

  const nseSummary = {};
  let totalViv = 0;
  for (const poly of polygons) {
    const inside = poly.getPath().getArray().some(pt =>
      google.maps.geometry.spherical.computeDistanceBetween(center, pt) <= radius
    );
    if (!inside) continue;
    const { NSE, VIV } = poly.customData;
    if (!NSE || !activeNSEs.has(NSE)) continue;
    nseSummary[NSE] = (nseSummary[NSE] || 0) + VIV;
    totalViv += VIV;
  }
  const nseRows = Object.entries(nseSummary).map(([nse, viv]) => ({
    NSE:        nse,
    '#Houses':  viv,
    '%': ((viv / totalViv) * 100).toFixed(1) + "%"
  }));
  const nseSheet = {
    sheetName: 'NSE',
    rows:      nseRows,
    sheet:     XLSX.utils.json_to_sheet(nseRows)
  };
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws1, "Stores");
  if (nseSheet.rows.length > 0) {
    XLSX.utils.book_append_sheet(wb, nseSheet.sheet, nseSheet.sheetName);
  }
  for (const { sheetName, sheet, rows } of propSheets) {
    if (rows.length > 0) {
      XLSX.utils.book_append_sheet(wb, sheet, sheetName);
    }
  }
  window.pendingWorkbook = wb;
  const modal = document.getElementById("filename-modal2");
  const container = document.fullscreenElement || document.body;
  container.appendChild(modal);
  modal.style.display = "block";
}


function reverseGeocode(latlng, callback) {
  const geocoder = new google.maps.Geocoder();
  geocoder.geocode({ location: latlng }, (results, status) => {
    if (status === "OK" && results.length) {
      const allComps = results.flatMap(r => r.address_components);
      const cityComp =
        allComps.find(c => c.types.includes("locality")) ||
        allComps.find(c => c.types.includes("postal_town")) ||
        allComps.find(c => c.types.includes("sublocality_level_1")) ||
        allComps.find(c => c.types.includes("administrative_area_level_2")) ||
        allComps.find(c => c.types.includes("administrative_area_level_1"));
      const city = cityComp?.long_name
        || results[0].formatted_address.split(",")[0]
        || "Ubicación desconocida";
      callback(city);
    } else {
      console.warn("Geocoder failed:", status);
      callback("Ubicación desconocida");
    }
  });
}

google.charts.load('current',{ packages:['corechart'] });
document.getElementById('category-select')
  .addEventListener('change', () => {
    if (currentCircle) showPopup2FromCircle(currentCircle);
  });
 
function showPopup2FromCircle(circle) {
  const center = circle.getCenter();
  const radius = circle.getRadius();
  const km = (radius / 1000).toFixed(1);

reverseGeocode(center, (address) => {
  const totalStores = currentCircleData.length;
  const headerEl = document.getElementById('popup2-header');
  let html = `
    <div style="font-size:12px;">
      Radius Analysis: ${km} km - ${address}
    </div>`;
  if (totalStores > 0) {
    html += `
      <div style="font-size:12px; font-weight:normal; margin-top:2px;">
        ${totalStores} store${totalStores === 1 ? '' : 's'} in the radius
      </div>`;
  }
  headerEl.innerHTML = html;
});

  const hasFranchiseData  = currentCircleData.length > 0;
  const hasSubcatData     = currentCircleData.some(m => !!m.subcategory);
  const hasOperationData  = currentCircleData.some(m => !!m.Operations);
  const propertyCats    = ['localesRenta','localesVenta','terrenosRenta','terrenosVenta'];
  const hasPropertyData = propertyCats.some(cat =>
    (propertyMarkers[cat] || []).some(m => {
      if (typeof m.getVisible !== 'function' || !m.getVisible()) return false;
      const pos = (m.getPosition?.() || m.getCenter?.());
      return pos &&
             google.maps.geometry.spherical
               .computeDistanceBetween(pos, center)
             <= radius;
    })
  );
  const vivPorNSE = {};
  const orderedNSE = [];
  for (const [nse, list] of Object.entries(nsePolygons)) {
    const key = nse.trim();
    if (!activeNSEs.has(key)) continue;
    list.forEach(poly => {
      const inside = poly.getPath().getArray().some(pt =>
        google.maps.geometry.spherical.computeDistanceBetween(pt, center) <= radius
      );
      if (inside) {
        vivPorNSE[key] = (vivPorNSE[key] || 0) + (poly.customData?.VIV || 0);
        if (!orderedNSE.includes(key)) orderedNSE.push(key);
      }
    });
  }
  const hasRealNSEData = orderedNSE.length > 0;
  document.getElementById('franchise-section').style.display      = hasFranchiseData   ? '' : 'none';
  document.getElementById('subcategory-section').style.display    = hasSubcatData      ? '' : 'none';
  document.getElementById('operation-section').style.display      = hasOperationData   ? '' : 'none';
  document.getElementById('operation-list-section').style.display = hasOperationData   ? '' : 'none';
  document.getElementById('scatter-section').style.display        = hasPropertyData    ? '' : 'none';
  document.getElementById('nse-section').style.display            = hasRealNSEData     ? '' : 'none';
  document.getElementById('list-section').style.display           = hasFranchiseData   ? '' : 'none';
  if (!(hasFranchiseData || hasSubcatData || hasOperationData || hasPropertyData || hasRealNSEData)) {
    document.getElementById('popup2').style.display = 'none';
    return;
  }
  document.getElementById('popup2').style.display = 'block';

const select = document.getElementById('category-select');

function drawScatterFor() {
  if (!currentCircle) return;

  const category = select.value;                 
  const center   = currentCircle.getCenter();
  const radius   = currentCircle.getRadius();

  const overlays = (propertyMarkers[category] || []).filter(o => {
    if (!o.getVisible()) return false;
    const pos = o.getPosition?.() || o.getCenter?.();
    if (!pos) return false;
    const dist = google.maps.geometry.spherical
      .computeDistanceBetween(pos, center);
    return dist <= radius;
  });
  console.log(`[scatter][${category}] overlays encontrados:`, overlays.length);

  const scatterData = overlays
    .map((o, i) => {
      const supRaw = o._props?.superficie;
      const preRaw = o._props?.precio;
      if (supRaw == null || preRaw == null) {
        console.warn(`[scatter][${category}][${i}] falta superficie/precio`, o._props);
        return null;
      }
      const sup = Number(String(supRaw).replace(/[^\d.-]/g, ''));
      const pre = Number(String(preRaw).replace(/[^\d.-]/g, ''));
      let supMin, supMax, preMin, preMax;
      switch (category) {
        case 'localesRenta':
          supMin = 50;    supMax = 350;
          preMin = 5000;  preMax = 250000;
          break;
        case 'localesVenta':
          supMin = 100;     supMax = 1500;
          preMin = 500000;  preMax = 10000000;
          break;
        case 'terrenosRenta':
          supMin = 100;    supMax = 10000;
          preMin = 2000;   preMax = 2000000;
          break;
        case 'terrenosVenta':
          supMin = 100;    supMax = 10000;
          preMin = 500;    preMax = 50000000;
          break;
        default:
          supMin = 0;      supMax = Infinity;
          preMin = 0;      preMax = Infinity;
      }
      if (isNaN(sup) || isNaN(pre) ||
          sup < supMin || sup > supMax ||
          pre < preMin || pre > preMax) {
        return null;
      }
      const valorM2 = pre / sup;
      const tip = `
        <div style="
          background: black;
          color: white;
          padding: 6px 8px;
          border-radius: 4px;
          font-size: 12px;
        ">
          Área: ${sup.toLocaleString(undefined, { maximumFractionDigits: 0 })} m²<br>
          MX$/m²: $${valorM2.toLocaleString(undefined, { maximumFractionDigits: 0 })}
        </div>`;
      return [ sup, valorM2, tip ];
    })
    .filter(r => r);
  console.log(`[scatter][${category}] scatterData length:`, scatterData.length);

  const table = new google.visualization.DataTable();
  table.addColumn('number', 'Area m²');
  table.addColumn('number', 'MX$/m²');
  table.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
  scatterData.forEach(row => table.addRow(row));

  const colorMap = { localesRenta:  '#9999FF',localesVenta:  '#9900CC',terrenosRenta: '#FF99FF',terrenosVenta: '#FF0099'};
  const chartColor = colorMap[category] || '#999999';

  new google.visualization.ScatterChart(
    document.getElementById('scatterchart')
  ).draw(table, {
    backgroundColor: chartsColor,
    legend:    'none',
    hAxis: {
      title: 'Area m²',
      titleTextStyle: { color: '#ff6600', fontSize: 12, bold: true },
      textStyle:      { color: '#ff6600', fontSize: 12 },
      gridlines:      { color: '#eee' }
    },
    vAxis: {
      title: 'MX$/m²',
      titleTextStyle: { color: '#ff6600', fontSize: 12, bold: true },
      textStyle:      { color: '#ff6600', fontSize: 12 },
      gridlines:      { color: '#eee' }
    },
    pointSize: 2,
    tooltip:   { isHtml: true },
    colors:    [ chartColor ]
  });

  const summaryEl = document.getElementById('scatter-summary');
  summaryEl.style.fontSize = '12px';
  summaryEl.style.color    = '#ff6600';
  if (scatterData.length) {
    const avgA = scatterData.reduce((s,[a])=>s + a, 0) / scatterData.length;
    const avgV = scatterData.reduce((s,[,v])=>s + v, 0) / scatterData.length;
    summaryEl.innerHTML =
      `# Properties Analyzed: ${scatterData.length}<br>` +
      `Avg. Area: ${avgA.toLocaleString(undefined, { maximumFractionDigits: 0 })} m² — ` +
      `Avg. MX$/m²: $${avgV.toLocaleString(undefined, { maximumFractionDigits: 0 })}`;
  } else {
    summaryEl.textContent = 'No hay datos válidos para el scatter.';
  }
}

  google.charts.load('current',{packages:['corechart']});
  google.charts.setOnLoadCallback(() => {
    drawScatterFor();
    select.addEventListener('change', drawScatterFor);
  
 
 
const nsePob = {};const franchiseCount = {};const subcategoryCount = {};const operationsCount = {};const operationsMap = {};let totalViv = 0;
 
for (const polygon of polygons) {
const path = polygon.getPath().getArray();
 
let inside = false;
 
for (const point of path) {
 
const dist = google.maps.geometry.spherical.computeDistanceBetween(center, point);
 
if (dist <= radius) {
 
inside = true;
 
break;
 
}
 
}
 
if (inside) {
 
const { NSE, POB, VIV } = polygon.customData;
 
if (!NSE || !activeNSEs.has(NSE)) continue;
 
nsePob[NSE] = (nsePob[NSE] || 0) + POB;
 
totalViv += VIV;
 
}
 
}
 
for (const marker of currentCircleData) {const franchise = marker.franchise || "Sin nombre";const subcategory = marker.subcategory || "Sin subcategoría";franchiseCount[franchise] = (franchiseCount[franchise] || 0) + 1;const operation = marker.Operations || "Sin operación";operationsCount[operation] = (operationsCount[operation] || 0) + 1;if (!operationsMap[operation]) operationsMap[operation] = new Set();const address = marker.Address || "Sin dirección";operationsMap[operation].add(address);subcategoryCount[subcategory] = (subcategoryCount[subcategory] || 0) + 1; }
 

document.getElementById("popup2-extra").innerText = `Total Houses: ${totalViv.toLocaleString()}`;//
const listContainer = document.getElementById('franchise-list');
listContainer.innerHTML = "";
const grouped = {};
let totalCount = 0;
currentCircleData.forEach(marker => {
  const cat = marker.category || "Sin categoría";
  const sub = marker.subcategory || "Sin subcategoría";
  const fra = marker.franchise || "Sin franquicia";
  const icon = marker.icon.url;
  const page = marker.webpage || "#";    
  if (!grouped[cat]) {
    grouped[cat] = { total: 0, subcategories: {} };
  }
  if (!grouped[cat].subcategories[sub]) {
    grouped[cat].subcategories[sub] = { total: 0, franchises: {} };
  }
  if (!grouped[cat].subcategories[sub].franchises[fra]) {
    grouped[cat].subcategories[sub].franchises[fra] = {
      count: 0,
      icon,
      webpage: page                  
    };
  }
  grouped[cat].total++;
  grouped[cat].subcategories[sub].total++;
  grouped[cat].subcategories[sub].franchises[fra].count++;
  totalCount++;
});

const sortedCategories = Object.entries(grouped).sort((a, b) => b[1].total - a[1].total);
sortedCategories.forEach(([cat, catData]) => {
const catPercent = ((catData.total / totalCount) * 100).toFixed(1);
const catDiv = document.createElement("div");
catDiv.style.marginTop = "10px";
catDiv.style.fontWeight = "bold";
catDiv.style.color = "#ff6600";
catDiv.textContent = `${cat} (${catData.total}) ${catPercent}%`;
listContainer.appendChild(catDiv);
const sortedSubcats = Object.entries(catData.subcategories).sort((a, b) => b[1].total - a[1].total);
sortedSubcats.forEach(([sub, subData]) => {
const subPercent = ((subData.total / catData.total) * 100).toFixed(1);
const subDiv = document.createElement("div");
 
subDiv.style.marginLeft = "15px";
subDiv.style.marginTop = "6px";  
subDiv.style.fontWeight = "bold";
subDiv.textContent = `${sub} (${subData.total}) ${subPercent}%`;
 
listContainer.appendChild(subDiv);
 
const fraDiv = document.createElement("div");
 
fraDiv.style.marginLeft = "25px";
fraDiv.style.marginBottom = "5px";
 
 
 
const fraList = Object.entries(subData.franchises)
 
.sort((a, b) => b[1].count - a[1].count)
 
.map(([name, { count, icon }]) =>
 
`<img src="${icon}" style="width:16px;vertical-align:middle;margin-right:4px;">${name} (${count})`
 
);
 
fraDiv.innerHTML = fraList.join(", ");
 
listContainer.appendChild(fraDiv);
 
});
 
});
 
 
const operationListContainer = document.getElementById("operation-list");
operationListContainer.innerHTML = "";
 
Object.entries(operationsMap)
.filter(([op]) => op !== "Free Standings")
.sort((a, b) => a[0].localeCompare(b[0]))
.forEach(([op, addressSet]) => {
 
const cleanedSet = new Set();
addressSet.forEach(addr => {
const trimmed = addr.trim();
if (trimmed) cleanedSet.add(trimmed);
 
});
 
const uniqueAddresses = Array.from(cleanedSet).sort().join(", ");
 
const div = document.createElement("div");
 
div.innerHTML = `<strong>${op}:</strong> ${uniqueAddresses}`;
 
div.style.marginBottom = "10px";
 
operationListContainer.appendChild(div);
 
});
  
const subData = new google.visualization.DataTable();
subData.addColumn('string', 'Subcategoría');
subData.addColumn('number', '# Stores');
subData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
subData.addColumn({ type: 'string', role: 'annotation' });
const sortedSubcategories = Object.entries(subcategoryCount)
 
.sort((a, b) => b[1] - a[1])
.slice(0, 5);

const subcategoryColors = [ '#ff6600', '#e65c00', '#cc5200', '#b34700', '#993d00', '#803300', '#662900', '#4d1f00', '#331400', '#1a0a00'];
 
let subMax = 0;
 
sortedSubcategories.forEach(([sub, count], index) => {
 
const percent = ((count / currentCircleData.length) * 100).toFixed(1);
 
const tooltip = `
 
  <div style="background:black; color:white; padding:6px 8px; border-radius:4px; font-size:12px;">
 
                <strong>${sub}</strong><br>
 
                ${percent}% (${count} stores)
 
  </div>`;
 
subData.addRow([sub, count, tooltip, String(count)]);
 
if (count > subMax) subMax = count;
 
});
 
 
 
const subChartContainer = document.getElementById('subcategorychart');
 
subChartContainer.innerHTML = "";
 
 
 
if (subData.getNumberOfRows() === 0) {
 
subChartContainer.innerHTML = `
 
  <div style="display:flex; justify-content:center; align-items:center; height:200px; color:#999; font-size:13px; font-family:'Segoe UI', sans-serif;">
 
                No Data
 
  </div>`;
 
} else {
 
const subBarChart = new google.visualization.ColumnChart(subChartContainer);
 
subBarChart.draw(subData, {
backgroundColor: chartsColor,
 
  legend: { position: 'none' },
 
  chartArea: { left: 40, width: '90%', height: '90%' },
 
  vAxis: {
 
                title: '# Stores',
 
                minValue: 0,
 
                maxValue: Math.ceil(subMax * 1.25),
 
                format: '0',
 
                gridlines: { color: '#ccc' },
 
                textStyle: { fontSize: 12 }
 
  },
 
  hAxis: {
 
                textPosition: 'none'
 
  },
 
  tooltip: { isHtml: true },
 
  colors: subcategoryColors.slice(0, sortedSubcategories.length),
 
  annotations: { alwaysOutside: true }
 
});
 
}
 
const subAxisMax = Math.ceil(subMax * 1.25);

 
const franchiseData = new google.visualization.DataTable();
franchiseData.addColumn('string', 'Franchise');
franchiseData.addColumn('number', '# Stores');
franchiseData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
franchiseData.addColumn({ type: 'string', role: 'annotation' });
franchiseData.addColumn({ type: 'string', role: 'style' });
 
const sortedFranchises = Object.entries(franchiseCount)
.sort((a, b) => b[1] - a[1])
.slice(0, 5);
 
const totalPines = currentCircleData.length;
 
const colorList = [
'#ff6600', '#e65c00', '#cc5200', '#b34700', '#993d00',
'#803300', '#662900', '#4d1f00', '#331400', '#1a0a00'
];
 
let colorIndex = 0;
let maxValue = 0;
 
for (const [name, count] of sortedFranchises) {
const percent = (count / totalPines) * 100;
 
 
 
const tooltip = `
 
  <div style="background:black; color:white; padding:6px 8px; border-radius:4px; font-size:12px;">
 
                <strong>${name}</strong><br>
 
                ${percent.toFixed(1)}% (${count} stores)
 
  </div>`;
 
 
 
const color = colorList[colorIndex % colorList.length];
 
franchiseData.addRow([name, count, tooltip, String(count), `color: ${color}`]);
 
if (count > maxValue) maxValue = count;
 
colorIndex++;
 
}
 
const franchisechart = new google.visualization.BarChart(document.getElementById('franchisechart'));
 
franchisechart.draw(franchiseData, {
backgroundColor: chartsColor,
legend: { position: 'none' },
chartArea: { left: 120, width: '100%', height: '85%'},
tooltip: { isHtml: true },
 
vAxis: {
  textPosition: 'out',
  textStyle: { fontSize: 11, fontWeight: 'bolder', color: chartsTextColor }
},
hAxis: {
  title: '# Stores',
  viewWindow: { max: Math.ceil(maxValue * 1.25) },
  format: '0',
  gridlines: { color: '#ccc' },
  textStyle: { fontSize: 12, color: chartsTextColor },
  titleTextStyle: { fontSize: 12, fontWeight: 'bolder', color: chartsTextColor }
},
annotations: {
  alwaysOutside: true,
  textStyle: {
    fontSize: 12,
    bold: true,
    color: chartsTextColor
  }
}
 
});
  
const operationData = new google.visualization.DataTable();
 
operationData.addColumn('string', 'Operation');
operationData.addColumn('number', '# Stores');
operationData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
 
const sortedOperations = Object.entries(operationsCount)
 
.sort((a, b) => b[1] - a[1])
.slice(0, 10);
 
for (const [op, count] of sortedOperations) {
 
const percent = ((count / totalPines) * 100).toFixed(1);
const tooltip = `
 
<div style="background:black; color:white; padding:6px 8px; border-radius:4px; font-size:12px;">
 
  <strong>${op}</strong><br>
 
  ${percent}% (${count} stores)
 
</div>`;
 
operationData.addRow([op, count, tooltip]);
 
}
 
const operationPie = new google.visualization.PieChart(document.getElementById('operationPieChart'));
 
operationPie.draw(operationData, {
backgroundColor: chartsColor,
legend: 'none',
chartArea: { width: '90%', height: '90%' },
colors: [ '#ff6600', '#e65c00', '#cc5200', '#b34700', '#993d00', '#803300', '#662900', '#4d1f00', '#331400', '#1a0a00'],
tooltip: { isHtml: true }
});
 
const nseData = new google.visualization.DataTable();
 
nseData.addColumn('string', 'NSE');
nseData.addColumn('number', 'Houses');
nseData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
 
const vivPorNSE = {};
const orderedNSE = [];
 
for (const [nse, polygonsList] of Object.entries(nsePolygons)) {
const normalizedNSE = nse.trim();
 
 
if (!activeNSEs.has(normalizedNSE)) continue;
 
for (const poly of polygonsList) {
 
const path = poly.getPath().getArray();
const inside = path.some(point =>
 google.maps.geometry.spherical.computeDistanceBetween(center, point) <= radius
 
);
 
if (inside) {
const viv = poly.customData?.VIV || 0;
 
if (!(normalizedNSE in vivPorNSE)) {
  vivPorNSE[normalizedNSE] = 0;
  orderedNSE.push(normalizedNSE);
}
 
vivPorNSE[normalizedNSE] += viv;
 
}}}
 
for (const nse of orderedNSE) {
 
const viviendas = vivPorNSE[nse];
 
const tooltip = `
 
  <div style="background:black; color:white; padding:6px 8px; border-radius:4px; font-size:12px;">
 
                <strong>${nse}</strong><br>
 
                ${viviendas.toLocaleString()} houses
 
  </div>`;
 
nseData.addRow([nse, viviendas, tooltip]);
}
 
const nseChart = new google.visualization.PieChart(document.getElementById('piechart'));
 
nseChart.draw(nseData, {
backgroundColor: chartsColor,
pieHole: 0.35,
legend: { position: 'none' },
chartArea: { width: '90%', height: '95%' },
colors: orderedNSE.map(nse => nseColors[nse] || '#ccc'),
tooltip: { isHtml: true },
sliceVisibilityThreshold: 0 

});
  
});
 
document.getElementById("popup2").style.display = "block";
 
}

</script>
 
<script>

function applyAllFilters() {
markers.forEach(marker => {
const op = marker.Operations?.trim() || "Sin operación";
const isOpActive = activeOperations.size === 0 || activeOperations.has(op);
const isFranchiseActive = marker.__visibleByFranchise || false;
const isLocationActive = activeLocationsFilter.has(marker.location);
const shouldBeVisible = isFranchiseActive && isOpActive && isLocationActive;
marker.setVisible(shouldBeVisible);
});
if (heatmap.getMap()) {
  updateHeatmapFromVisibleMarkers();
}
updatePopupIfCircleExists?.();
 
}
function isCategoryVisible(categoryGroup) {
 
for (const sub in categoryGroup) {
 
if (!isSubcategoryVisible(categoryGroup[sub])) return false;
 
}
 
return true;
 
}
function isSubcategoryVisible(subGroup) {
for (const fra in subGroup) {
if (!subGroup[fra][0].__visibleByFranchise) return false;
}
return true;
 
}
function selectAllMarkers() {
markers.forEach(marker => {
marker.__visibleByFranchise = true;
 
});
 
applyAllFilters();
buildFilterPanelGlobal();
}
function deselectAllMarkers() {
markers.forEach(marker => {
marker.__visibleByFranchise = false;
 
});
applyAllFilters();
buildFilterPanelGlobal();
const panel = document.getElementById("pin-control-content");
 
panel.querySelectorAll("details").forEach(d => d.open = false);
 
}

function updatePopupIfCircleExists() {if (currentCircle) {currentCircleData = markers.filter(marker => {const dist = google.maps.geometry.spherical.computeDistanceBetween(currentCircle.getCenter(),marker.getPosition());return dist <= currentCircle.getRadius() && marker.getVisible(); }); showPopup2FromCircle(currentCircle);}}
 
document.addEventListener("fullscreenchange", () => {
 
const fs = document.fullscreenElement;
 
const ids = [
"popup", "popup2", "menu-button", "filter-panel","autocomplete-container","city-panel","traffic-panel",
"settings-panel","city-options-panel","retail-options-panel","residential-options-panel","traffic-options-panel","municipios-panel","reports-options-panel","portfolio-options-panel",
"poi-search-box","export-files-panel","import-files-panel","draw-tools-panel",
"ruler-popup","tooltip","filename-modal","filename-modal2","bottom-image-container","toolbar","dev-toolbar","research-pin-form",
];
 
ids.forEach(id => {
const el = document.getElementById(id);
if (!el) return;
 
if (fs) {
 
try {
 
  fs.appendChild(el);
 
} catch (e) {
 
  console.warn(`No se pudo mover ${id} a fullscreen`, e);
 
}
 
} else {
 
try {
 
  document.body.appendChild(el);
 
} catch (e) {
 
  console.warn(`No se pudo restaurar ${id}`, e);
 
}
 
}
 
});
 
if (currentCircle && document.getElementById("popup2").style.display === "block") {
 
setTimeout(() => showPopup2FromCircle(currentCircle), 100);
}
});
 
function closePopup() { document.getElementById("popup").style.display = "none";}
 
function closePopup2() {document.getElementById("popup2").style.display = "none";if (currentCircle) {currentCircle.setMap(null);currentCircle = null;}}

function promptSaveAnalysis() {
  let modal = document.getElementById("filename-modal");
  const input = document.getElementById("filename-input");
  if (!modal) {
	modal = document.createElement("div");
	modal.id = "filename-modal";
	modal.innerHTML = `
  	<p>Do you want to save the report?</p>
  	<input id="filename-input" type="text" />
  	<div>
    	<button onclick="confirmDownload()">Save Analysis</button>
    	<button onclick="cancelDownload()">Cancelar</button>
  	</div>`;
	document.body.appendChild(modal);
  }
  input.value = "analysis_" + new Date().toISOString().slice(0, 10);
  modal.dataset.mode = "analysis";
  modal.style.display = "block";
  if (!document.body.contains(modal)) {
	document.body.appendChild(modal);
  }
}
 
function confirmDownload() {
 
  const fileName = document.getElementById("filename-input").value.trim();
  const fileName2 = document.getElementById("filename-input2").value.trim();
  if (!fileName) {
	showToast("Por favor ingresa un nombre para el archivo.");
	return;
  }
  const modal = document.getElementById("filename-modal");
  const modal2 = document.getElementById("filename-modal2");
  modal.style.display = "none";
  modal2.style.display = "none";
  if (!document.body.contains(modal)) {
	document.body.appendChild(modal);
  }
  if (window.pendingWorkbook) {
	XLSX.writeFile(window.pendingWorkbook, `${fileName2}.xlsx`);
	window.pendingWorkbook = null;
	return;
  }
  if (window.pendingAnalysisData) {
	exportAnalysis(window.pendingAnalysisData);
  }
}
 
function cancelDownload() {document.getElementById("filename-modal").style.display = "none"; document.getElementById("filename-modal2").style.display = "none"; window.pendingWorkbook = null;}
 
 
function loadTrafficData() {
  fetch(SHEET_TRAFFIC)
    .then(res => res.text())
    .then(csv => {
      Papa.parse(csv, {
        header: true,
          transformHeader: h => h.trim().toLowerCase(),  
        skipEmptyLines: true,
        complete: results => {
          const tooltip = document.getElementById("tooltip");
          const avenueGrouped = {}; 
          const polylines = [];

          results.data.forEach(row => {
            const wkt      = row.wkt?.trim();
            const avenue = row.avenue?.trim() || "Unnamed Avenue";
            const type     = row.type?.trim()     || "Main Thoroughfares";
            const location = row.location?.trim() || "Unknown";
            const typeLower = type.toLowerCase();

            if (!wkt || !wkt.startsWith("LINESTRING")) return;

            try {
              const path = parseWKTLine(wkt);

              let color = "#ff6600";
              if (typeLower === "urban train")       color = "#ff0000";
              else if (typeLower === "main thoroughfares") color = "#000000";
              else return; 

              const polyline = new google.maps.Polyline({path,geodesic: true,strokeColor: color,strokeOpacity: 0.85,strokeWeight: 5,zIndex: 99,map: null});

              polyline.customType   = type;
              polyline.customAvenue = avenue;
              if (!window.avenuePolylines) window.avenuePolylines = [];
              window.avenuePolylines.push(polyline);

              const stateName = row.state?.trim() || "Unknown State";
              if (!avenueGrouped[stateName])            avenueGrouped[stateName] = {};
              if (!avenueGrouped[stateName][type])      avenueGrouped[stateName][type] = {};

              if (typeLower === "urban train") {
                if (!avenueGrouped[stateName][type][avenue]) 
                  avenueGrouped[stateName][type][avenue] = [];
                avenueGrouped[stateName][type][avenue].push(polyline);
              } else {
                if (!avenueGrouped[stateName][type][location]) 
                  avenueGrouped[stateName][type][location] = {};
                if (!avenueGrouped[stateName][type][location][avenue]) 
                  avenueGrouped[stateName][type][location][avenue] = [];
                avenueGrouped[stateName][type][location][avenue].push(polyline);
              }

              polyline.addListener("mouseover", () => {
                tooltip.style.display = "block";
                tooltip.textContent = avenue;
              });
              polyline.addListener("mousemove", e => {
                const pos = tooltipOverlay
                  .getProjection()
                  .fromLatLngToDivPixel(e.latLng);
                const offsetX = 0, offsetY = -10;
                tooltip.style.left = `${pos.x + offsetX}px`;
                tooltip.style.top  = `${pos.y + offsetY}px`;
              });
              polyline.addListener("mouseout", () => {
                tooltip.style.display = "none";
              });

              polylines.push({ polyline, avenue });
            } catch (e) {
              console.warn("Error al procesar línea:", e);
            }
          });

          buildGroupedAvenueControl(avenueGrouped);
        }
      });
    });

  document.getElementById("selectAllAvenues").onclick = () => {
    document
      .querySelectorAll("#avenue-control-content input[type='checkbox']")
      .forEach(cb => {
        cb.checked = true;
        cb.dispatchEvent(new Event("change"));
      });
  };

  document.getElementById("clearAllAvenues").onclick = () => {
    document
      .querySelectorAll("#avenue-control-content input[type='checkbox']")
      .forEach(cb => {
        cb.checked = false;
        cb.dispatchEvent(new Event("change"));
      });
  };
} 
</script>
 
<div id="toast"></div>
  
<div id="filename-modal" style="display: none;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);background: white;border: 2px solid #ff6600;border-radius: 10px;padding: 20px;z-index: 100000;box-shadow: 0 4px 10px rgba(0,0,0,0.3);text-align: center;font-family: 'Segoe UI', sans-serif;">
 
<p style="margin-bottom: 10px;">Do you want to save the report?:</p>
 
<input id="filename-input" type="text" value="file1" style="padding: 8px;width: 85%;border: 1px solid #ccc;border-radius: 4px;margin-bottom: 15px;font-size: 12px;"/>
 
<div>
 
<button onclick="confirmDownload()" style=" background: #ff6600; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-right: 10px; ">Save Analysis</button>
<button onclick="cancelDownload()" style="background: gray;color: white;border: none;padding: 8px 16px;border-radius: 5px;cursor: pointer;">Cancel</button>

</div>

</div>
 
<div id="filename-modal2" style="display: none;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);background: white;border: 2px solid #ff6600;border-radius: 10px;padding: 20px;z-index: 100000;box-shadow: 0 4px 10px rgba(0,0,0,0.3);text-align: center;font-family: 'Segoe UI', sans-serif;">
 
  <p style="margin-bottom: 10px;">Do you want to save the report?:</p>
  
  <input id="filename-input2" type="text" value="file1" style="padding: 8px;width: 85%;border: 1px solid #ccc;border-radius: 4px;margin-bottom: 15px;font-size: 12px;"/>
  
  <div>

<button onclick="confirmDownload()" style="background: #ff6600;color: white;border: none;padding: 8px 16px;border-radius: 5px;cursor: pointer;margin-right: 10px;">Save Analysis</button>
<button onclick="cancelDownload()" style="background: gray;color: white;border: none;padding: 8px 16px;border-radius: 5px;cursor: pointer;">Cancel</button>

</div>

</div>

<script>
 
let searchableItems = [];
function populateSearchIndex() {
searchableItems = markers.map(marker => ({
label: `${marker.franchise} - ${marker.Address} - ${marker.location}`,
marker: marker
}));
}

function setupAutocomplete() {
const input = document.getElementById("search-input");
const resultsContainer = document.getElementById("autocomplete-results");
input.addEventListener("input", () => {
const term = input.value.trim().toLowerCase();
resultsContainer.innerHTML = "";
 
if (!term) {
 
  resultsContainer.style.display = "none";
 
  return;
 
}
 
 const matches = searchableItems.filter(item =>
 
  item.label.toLowerCase().includes(term)
 
).slice(0, 100);
 
 if (matches.length === 0) {
 
  resultsContainer.style.display = "none";
 
  return;
 
}
 
matches.forEach(match => {
const div = document.createElement("div");
div.textContent = match.label;
div.style.padding = "6px 8px";
div.style.cursor = "pointer";
div.onmouseover = () => {
div.style.backgroundColor = "#ff6600";     
div.style.borderRadius = "3px";
div.style.color = "white";
};
 
div.onmouseout = () => {
div.style.backgroundColor = "white";
div.style.color = "black";
div.style.border = "none";
};
 
  div.onclick = () => {
 
              	input.value = "";
 
              	resultsContainer.style.display = "none";
 
              	focusOnMarker(match.marker);
 
              	console.log("Focusing on:", match.marker.franchise);
 
  };
 
  resultsContainer.appendChild(div);
 
});
 
 resultsContainer.style.display = "block";
 
});
 
document.addEventListener("click", (e) => {
 
if (!document.getElementById("autocomplete-container").contains(e.target)) {
 
  resultsContainer.style.display = "none";
}
});
}
function focusOnMarker(marker) {
const franchiseName = marker.franchise;
const subcategory = marker.subcategory;
const category = marker.category;
markers.forEach(m => {
if (m.franchise === franchiseName) {
m.__visibleByFranchise = true;
m.setVisible(true);
}
});
const pinPanel = document.getElementById("pin-control-content");
const categoryDetails = Array.from(pinPanel.querySelectorAll("details.dropdown"))
.find(d => d.querySelector("summary span")?.textContent === category);
if (categoryDetails) {
categoryDetails.open = true;
const subcategoryDetails = Array.from(categoryDetails.querySelectorAll("details.dropdown"))
.find(d => d.querySelector("summary span")?.textContent === subcategory);
if (subcategoryDetails) {
subcategoryDetails.open = true;
const franchiseButton = Array.from(subcategoryDetails.querySelectorAll(".toggle-btn"))
  .find(btn => btn.textContent.includes(franchiseName));
if (franchiseButton && !franchiseButton.classList.contains("active")) {
  franchiseButton.classList.add("active");
}
}
}
applyAllFilters();
buildFilterPanelGlobal();
map.setCenter(marker.getPosition());
map.setZoom(17);
const content = `
<div style="font-size:13px;">
<strong>${marker.franchise}</strong><br>
${marker.Address}<br>
${marker.subcategory} – ${marker.Operations}
</div>`;
const infoWindow = new google.maps.InfoWindow({ content });
infoWindow.open(map, marker);
}
function closeAllPanelsAndPopups() {
const trafficPanel = document.getElementById("traffic-panel");
const cityPanel = document.getElementById("city-panel");
trafficPanel.dataset.wasVisible = trafficPanel.style.display === "block";
cityPanel.dataset.wasVisible = cityPanel.style.display === "block";
trafficPanel.style.display = "none";
cityPanel.style.display = "none";
document.getElementById("autocomplete-container").style.display = "none";
const popup = document.getElementById("popup");
const popup2 = document.getElementById("popup2");
if (popup) popup.style.display = "none";
if (popup2) popup2.style.display = "none";
}
document.getElementById("traffic-toggle").addEventListener("click", () => {
  deactivateAllTrafficLayers();
  const panel = document.getElementById("traffic-panel");
  const toggle = document.getElementById("traffic-toggle");
  const wasVisible = panel.style.display === "block";
  closeAllPanelsAndPopups();
  if (!wasVisible) {
    panel.style.display = "block";
    toggle.classList.add("active-toggle");
  } else {
    toggle.classList.remove("active-toggle");
  }
});
document.getElementById("search-toggle").addEventListener("click", (e) => {
const container = document.getElementById("autocomplete-container");
const wasVisible = container.style.display === "block";
closeAllPanelsAndPopups();
if (!wasVisible) container.style.display = "block";
e.stopPropagation();
});
document.getElementById("reset-button").addEventListener("click", () => {
  if (confirm("Sure you want to restart? Any unsaved changes will be lost.")) {localStorage.removeItem("customPolygons");localStorage.removeItem("customPins");localStorage.removeItem("importedKMZ");localStorage.removeItem("researchPins");localStorage.removeItem("excelData");localStorage.removeItem("portfolioSheetURL");location.reload();
}
});
document.getElementById("pin-toggle").addEventListener("click", () => {
if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(
              	(position) => {
 const pos = {
lat: position.coords.latitude,
lng: position.coords.longitude,
};
map.setCenter(pos);
map.setZoom(15);
if (userLocationMarker) {
userLocationMarker.setMap(null);
}
userLocationMarker = new google.maps.Marker({
position: pos,
map: map,
icon: {path: google.maps.SymbolPath.CIRCLE,scale: 8,fillColor: "#ff6600",fillOpacity: 1,strokeColor: "white",strokeWeight: 3,},
});
},
() => {

showToast("No se pudo obtener tu ubicación.");
}
  );
} else {
  showToast("Geolocalización no es soportada por tu navegador.");
}
});
document.addEventListener("click", (e) => {
const container = document.getElementById("autocomplete-container");
const toggle = document.getElementById("search-toggle");
if (!container.contains(e.target) && !toggle.contains(e.target)) {
  container.style.display = "none";
}
});
document.addEventListener("fullscreenchange", () => {
const fs = document.fullscreenElement;
const ids = [
"popup", "popup2", "menu-button", "filter-panel","city-panel","traffic-panel",
"autocomplete-container","local-pin-options","poi-search-box","export-files-panel","import-files-panel","notes-panel","reports-options-panel","portfolio-options-panel",
"settings-panel","city-options-panel","retail-options-panel","residential-options-panel","traffic-options-panel","draw-tools-panel","municipios-panel",
"ruler-popup","tooltip","filename-modal","filename-modal2","bottom-image-container","toolbar","research-pin-form","dev-toolbar",
];

ids.forEach(id => {
  const el = document.getElementById(id);
 
  if (!el) return;
  try {
              	(fs || document.body).appendChild(el);
  } catch (e) {
              	console.warn(`No se pudo mover ${id}`, e);
  }
});

const trafficPanel = document.getElementById("traffic-panel");
const cityPanel = document.getElementById("city-panel");
if (trafficPanel.dataset.wasVisible === "true") {
trafficPanel.style.display = "block";
document.getElementById("traffic-toggle").classList.add("active-toggle");
} else {
document.getElementById("traffic-toggle").classList.remove("active-toggle");
}
if (cityPanel.dataset.wasVisible === "true") {
cityPanel.style.display = "block";
document.getElementById("city-toggle").classList.add("active-toggle");
} else {
document.getElementById("city-toggle").classList.remove("active-toggle");
}

if (currentCircle && document.getElementById("popup2").style.display === "block") {
 setTimeout(() => showPopup2FromCircle(currentCircle), 100);
}
});
function closeTrafficPanel() {
document.getElementById('traffic-panel').style.display = 'none';
document.getElementById("traffic-toggle").classList.remove("active-toggle");
if (currentCircle && currentCircleData.length > 0) {
document.getElementById("popup2").style.display = "block";
}
}
function closeCityPanel() {
document.getElementById('city-panel').style.display = 'none';
document.getElementById("city-toggle").classList.remove("active-toggle");
if (currentCircle && currentCircleData.length > 0) {
document.getElementById("popup2").style.display = "block";
 }
}
 
function activatePinMode() {
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";  
  showToast("Click on the Map to add a Custom Marker.");
  map.setOptions({ draggableCursor: "crosshair" });
  google.maps.event.clearListeners(map, "click");
  const clickListener = map.addListener("click", function (e) {
    const name = prompt("¿Marker Name?");
    if (!name) return;
  
const position = { lat: e.latLng.lat(), lng: e.latLng.lng(),};

    playSound("sounds/bubble.mp3");
    const icon = {
      url: "https://static.wixstatic.com/media/805cf6_c60c413bdd6545f78929a4d92196dcd5~mv2.png",
      scaledSize: new google.maps.Size(30, 30)
    };
    const marker = new google.maps.Marker({ title: name, position, map, animation: google.maps.Animation.DROP, draggable: true, icon,});

    marker.addListener("click", () => {
      const confirmDelete = confirm(`Delete Marker "${name}"?`);
      if (confirmDelete) {
        marker.setMap(null);
        playSound("sounds/trash.mp3");
        localPins = localPins.filter(p => p.name !== name || p.position.lat !== position.lat || p.position.lng !== position.lng);
        savePinsToStorage();
      }
    });
    localPins.push({ name, position, icon });
    savePinsToStorage();
    google.maps.event.removeListener(clickListener);
    map.setOptions({ draggableCursor: null });
    showToast("Marker Succesful Saved!");
  });
}
const darkModeBtn = document.getElementById("dark-mode");
darkModeBtn.addEventListener("click", () => {
  const isDark = document.body.classList.toggle("dark-mode");
  rulerColor = isDark ? "#FF6600" : "#000000";

drawnPolygons.forEach(polygon => { polygon.setOptions({strokeColor: isDark ? "#FF6600" : "#000000",fillColor: isDark ? "#FF6600" : "#000000",fillOpacity: 0.25,}); });

customPolygons.forEach(polygon => { polygon.setOptions({strokeColor: isDark ? "#FF6600" : "#000000",fillColor: isDark ? "#FF6600" : "#000000",fillOpacity: fillOpacityLevel,});});

  Object.keys(locationPolygons).forEach(city => {

locationPolygons[city].forEach(polygon => { polygon.setOptions({strokeColor: isDark ? '#FFFFFF' : '#ff6600',fillColor: isDark ? '#ff6600' : '#000000', fillOpacity: isDark ? 'fillOpacityLevel' : 'fillOpacityLevel'});

window.excelPolygons.forEach(polygon => { polygon.setOptions({strokeColor: isDark ? '#FFFFFF' : '#ff6600',fillColor: isDark ? '#ff6600' : '#000000',fillOpacity: isDark ? 'fillOpacityLevel' : 'fillOpacityLevel'});});
    
  });
});
  
if (window.avenuePolylines) {
  avenuePolylines.forEach(polyline => {
    const type = polyline.customType.toLowerCase();
    let newColor = "#ff6600"; 
    if (type === "urban train") {
      newColor = isDark ? "#FF7777" : "#ff0000";
    } else if (type === "highways") {
      newColor = isDark ? "#CCCCCC" : "#333333";
    } else if (type === "main thoroughfares") {
      newColor = isDark ? "#FEF4E8" : "#000000";
    }
    polyline.setOptions({ strokeColor: newColor });
  });
}
  map.setOptions({
	styles: isDark ? darkMapStyle : null
  });
  
  localStorage.setItem("darkMode", isDark ? "true" : "false");
});
window.addEventListener("DOMContentLoaded", () => {
  const stored = localStorage.getItem("darkMode");
  const icon = document.getElementById("dark-mode-icon");
  if (stored === "true") {
    document.body.classList.add("dark-mode");
    if (map) map.setOptions({ styles: darkMapStyle });
    icon.src = "https://img.icons8.com/?size=60&id=59810&format=png";
    icon.alt = "Light Mode";
  }
});
document.getElementById("dark-mode").addEventListener("click", () => {
  isDarkMode = !isDarkMode;
  const icon = document.getElementById("dark-mode-icon");
  if (isDarkMode) {
    map.setOptions({ styles: darkMapStyle });
    document.body.classList.add("dark-mode");
    icon.src = "https://img.icons8.com/?size=60&id=59810&format=png"; 
    icon.alt = "Light Mode";
  } else {
    map.setOptions({ styles: lightMapStyle });
    document.body.classList.remove("dark-mode");
    icon.src = "https://img.icons8.com/?size=60&id=59841&format=png";
    icon.alt = "Dark Mode";
  }
  localStorage.setItem("darkMode", isDarkMode ? "true" : "false");
});
window.addEventListener("load", () => {
  const storedDarkMode = localStorage.getItem("darkMode") === "true";
  if (storedDarkMode) {
    document.getElementById("dark-mode").click(); 
  }
});

window.addEventListener("DOMContentLoaded", () => {
  document.getElementById("pins-research").addEventListener("click", () => {
	map.setOptions({ draggableCursor: "crosshair" }); 
    researchPinMode = true;
  });
});

function closeResearchPinForm() { document.getElementById("research-pin-form").style.display = "none";researchPinMode = false;selectedResearchCoords = null;map.setOptions({ draggableCursor: null });}

function parseWKT(wkt) { const match = wkt.match(/POINT\s*\(\s*([-\d\.]+)\s+([-\d\.]+)\s*\)/i); if (!match) return null; return { lng: parseFloat(match[1]), lat: parseFloat(match[2]) };}

let poiVisible = false; 
document.getElementById("activate-poi").addEventListener("click", () => {
  poiVisible = !poiVisible;
  const currentType = map.getMapTypeId();
  if (poiVisible && currentType === google.maps.MapTypeId.SATELLITE) {
    map.setMapTypeId(google.maps.MapTypeId.HYBRID);
    setTimeout(() => {
      map.setOptions({ styles: getPoiStyle(true) });
    }, 100);
  } else if (!poiVisible && currentType === google.maps.MapTypeId.HYBRID) {
    map.setOptions({
      styles: null 
    });
    setTimeout(() => {
      map.setMapTypeId(google.maps.MapTypeId.SATELLITE);
    }, 100);
  } else {
    map.setOptions({ styles: getPoiStyle(poiVisible) });
  }

  const poiIcon2 = document.getElementById("activate-poi");
  poiIcon2.src = poiVisible
    ? "images/icons/poi-off.png"
    : "images/icons/poi-on.png";
  poiIcon2.alt = poiVisible ? "POI ON" : "POI OFF";
});
function getPoiStyle(show) {
  if (show) {
    const baseStyle = isDarkMode ? darkMapStyle : lightMapStyle;
    const poiStyles = [
      { featureType: "poi", stylers: [{ visibility: "on" }] },
      { featureType: "poi.attraction", stylers: [{ visibility: "on" }] },
      { featureType: "poi.business", stylers: [{ visibility: "on" }] },
      { featureType: "poi.government", stylers: [{ visibility: "on" }] },
      { featureType: "poi.medical", stylers: [{ visibility: "on" }] },
      { featureType: "poi.place_of_worship", stylers: [{ visibility: "on" }] },
      { featureType: "poi.school", stylers: [{ visibility: "on" }] },
      { featureType: "poi.sports_complex", stylers: [{ visibility: "on" }] },
      { featureType: "poi.restaurant", stylers: [{ visibility: "on" }] }
    ];
    return [...baseStyle, ...poiStyles];
  } else {
    return isDarkMode ? darkMapStyle : lightMapStyle;
  }
}
async function searchPlacesByText(query) {
  const bounds = map.getBounds();
  if (!bounds) return [];
  const center = bounds.getCenter();
  const ne = bounds.getNorthEast();
  const radius = google.maps.geometry.spherical.computeDistanceBetween(center, ne);
  const response = await fetch("https://places.googleapis.com/v1/places:searchText", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Goog-Api-Key": "AIzaSyBimPrRAY6NuxHcucxTpZ5hxW39CDnvnLM",
      "X-Goog-FieldMask": "places.location,places.displayName"
    },
    body: JSON.stringify({
      textQuery: query,
      maxResultCount: 50,
      locationBias: {
        circle: {
          center: {
            latitude: center.lat(),
            longitude: center.lng()
          },
          radius: radius
        }
      }
    })
  });
  if (!response.ok) {
    const error = await response.text();
    console.error("Error al buscar:", error);
    alert("You are too far from the search range. Zoom in and try again");
    return [];
  }
  const data = await response.json();
  return data.places || [];
}
function renderPOIMarkers(places) {
  poiMarkers.forEach(m => m.setMap(null));
  poiMarkers = [];
  for (const place of places) {
    const position = {
      lat: place.location.latitude,
      lng: place.location.longitude
    };
    const marker = new google.maps.Marker({
      position,
      map,
      title: place.displayName?.text || "POI"
    });
    poiMarkers.push(marker);
  }
  if (places.length > 0) {
    map.setCenter({
      lat: places[0].location.latitude,
      lng: places[0].location.longitude
    });
  } else {
    alert("Coincidences not found!");
  }
  console.log("Places encontrados:", places.length, places);
}
const devToggleButton = document.getElementById("dev-mode");
const devToolbar = document.getElementById("dev-toolbar");
let devPasswordValidated = localStorage.getItem("devPasswordValidated") === "true";
let devToolbarVisible   = devPasswordValidated;
if (devPasswordValidated) {
  devToolbar.style.display = "flex";
  devToolbarVisible = true;
}
devToggleButton.addEventListener("click", () => {
  if (!devPasswordValidated) {
    const password = prompt("Admin Password:");
    if (password === "mkts2007") {
      devPasswordValidated = true;
      localStorage.setItem("devPasswordValidated", "true");
      devToolbar.style.display = "flex";
      devToolbarVisible = true;
    } else if (password !== null) {
      alert("Wrong Password.");
    }
  } else {
    devToolbarVisible = !devToolbarVisible;
    devToolbar.style.display = devToolbarVisible ? "flex" : "none";
  }
});
function playSound(src) {
  if (!isSoundEnabled) return;
  const audio = new Audio(src);
  audio.play();
}
document.getElementById("sound-toggle").addEventListener("click", () => {
  isSoundEnabled = !isSoundEnabled;
  localStorage.setItem('soundEnabled', isSoundEnabled);
  updateSoundButton();
});
function updateSoundButton() {
  const btn = document.getElementById("sound-toggle");
  const iconUrl = isSoundEnabled
    ? "https://img.icons8.com/?size=48&id=iWO20ZvCeU53&format=png"
    : "https://img.icons8.com/?size=48&id=J8AUGZ0QFMe0&format=png";
  btn.innerHTML = `<img src="${iconUrl}" alt="sound-toggle" style="width:20px; height:20px;">`;
}
navigator.storage.estimate().then(({ usage, quota }) => {
});
 
    document.addEventListener('DOMContentLoaded', () => {
      const categories = ['localesRenta','localesVenta','terrenosRenta','terrenosVenta'];
      const toggleAllBtn = document.getElementById('toggle-all-properties');
      const checkboxes = categories.map(cat =>
        document.getElementById(
          `toggle-${cat.replace(/([A-Z])/g, '-$1').toLowerCase()}`
        )
      );
      checkboxes.forEach(cb => {
        cb.addEventListener('change', () => {
          const cat = cb.dataset.cat;
          markers.forEach(marker => {
            if (marker.category === cat) {
              marker.setVisible(cb.checked);
            }
          });
        });
      });
      toggleAllBtn.addEventListener('click', () => {
        const allChecked = checkboxes.every(cb => cb.checked);
        checkboxes.forEach(cb => {
          cb.checked = !allChecked;
          cb.dispatchEvent(new Event('change'));
        });
      });
    });
    function deactivateAllTrafficLayers() {
  if (trafficLayer) {
    trafficLayer.setMap(null);
  }
  if (trafficPolylineList && trafficPolylineList.length) {
    trafficPolylineList.forEach(poly => poly.setMap(null));
    trafficPolylineList = [];
    trafficIsVisible = false;
  }
  const genPanel = document.getElementById("traffic-panel");
  if (genPanel.style.display === "block") {
    genPanel.style.display = "none";
    document.getElementById("traffic-toggle").classList.remove("active-toggle");
  }
  document.querySelectorAll("#avenue-control-content input[type='checkbox']").forEach(cb => {
    if (cb.checked) {
      cb.checked = false;
      cb.dispatchEvent(new Event("change"));
    }
  });
}
 
const GRID_RADIUS = 25000;
const GRID_SPACING = 200;

function getMetrics(center, radius) {
  const circleBounds = new google.maps.Circle({ center, radius }).getBounds();

  let totalVIV = 0;
  const nseCounts = {};

  for (const poly of window.allNsePolygons) {
    if (!circleBounds.intersects(poly._bounds)) continue;

    let inside = false;
    if (google.maps.geometry.poly.containsLocation(center, poly)) {
      inside = true;
    } else {
      for (const pt of poly.getPath().getArray()) {
        if (
          google.maps.geometry.spherical.computeDistanceBetween(pt, center) <=
          radius
        ) {
          inside = true;
          break;
        }
      }
    }
    if (!inside) continue;

    const viv = poly.customData?.VIV || 0;
    totalVIV += viv;
    const nse = poly.customData?.NSE || "Desconocido";
    nseCounts[nse] = (nseCounts[nse] || 0) + viv;
  }

  const topNSEs = Object.entries(nseCounts)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 2)
    .map(([nse]) => nse);

const roadLines = window.avenuePolylines
  .filter(pl => pl.customType.toLowerCase() === "main thoroughfares")
  .map(pl => ({ polyline: pl, avenue: pl.customAvenue }));
  if (!roadLines.length) {
    console.warn(
      'No encontré líneas “Main Thoroughfares”. Revisa tu CSV en la columna `type`.'
    );
  }
  const roadDists = roadLines
    .map(({ polyline, avenue }) => {
          console.log('🛣️ roadLines entry:', { customAvenue: polyline.customAvenue, avenue });

      const dist = polyline
        .getPath()
        .getArray()
        .reduce((min, pt) => {
          const d = google.maps.geometry.spherical.computeDistanceBetween(
            pt,
            center
          );
          return Math.min(min, d);
        }, Infinity);
      return { name: avenue || "Sin nombre", dist };
    })
    .sort((a, b) => a.dist - b.dist)
    .slice(0, 3);
    console.log('🗺️ roadDists final:', roadDists);


  return {totalVIV,nseCounts,topNSEs,roadDists,};}

 function snapToGrid(latlng, spacing) {
  const R = 6371000; 
  const lat = latlng.lat();
  const lng = latlng.lng();

  const degPerMeterLat = 1 / 111320;
  const degPerMeterLng = 1 / (111320 * Math.cos(lat * Math.PI/180));

  const latStep = spacing * degPerMeterLat;
  const lngStep = spacing * degPerMeterLng;

  const snappedLat = Math.round(lat / latStep) * latStep;
  const snappedLng = Math.round(lng / lngStep) * lngStep;

  return new google.maps.LatLng(snappedLat, snappedLng);
}



 function generateGrid(center, gridRadius = GRID_RADIUS, spacing = GRID_SPACING) {
  const nePoint = google.maps.geometry.spherical.computeOffset(center, gridRadius, 45);
  const swPoint = google.maps.geometry.spherical.computeOffset(center, gridRadius, 225);
  const bounds = new google.maps.LatLngBounds(swPoint, nePoint);

  const latStep = spacing / 111000;
  const centerLat = center.lat() * Math.PI / 180;
  const lngStep = spacing / (111000 * Math.cos(centerLat));

  const pts = [];
  for (let lat = bounds.getSouthWest().lat(); lat <= bounds.getNorthEast().lat(); lat += latStep) {
    for (let lng = bounds.getSouthWest().lng(); lng <= bounds.getNorthEast().lng(); lng += lngStep) {
      const pt = new google.maps.LatLng(lat, lng);
      if (google.maps.geometry.spherical.computeDistanceBetween(center, pt) <= gridRadius) {
        pts.push(pt);
      }
    }
  }
  return pts;
}

async function performAnalysis(marker) {
  console.log('▶ performAnalysis disparado para:', marker.franchise);

  const km        = parseFloat(prompt('Radius (km):', maxCircleRadius/1000));
  const radius    = (isNaN(km) ? maxCircleRadius/1000 : km) * 1000;
  const numResults= parseInt(prompt('¿Cuántos candidatos mostrar?', '3'), 10) || 3;
  const threshold = parseInt(prompt('Umbral (0–100):', '85'), 10) || 85;

  showLoading();

  await analyzeFranchise(marker.franchise,marker.getPosition(),radius,numResults,threshold);

  hideLoading();
}

function isUrban(latLng) {
  for (const poly of window.allNsePolygons) {
    if (!poly._bounds.contains(latLng)) continue;
    if (google.maps.geometry.poly.containsLocation(latLng, poly)) {
      return true;
    }
  }
  return false;
}

 function formatMMSS(totalSeconds) { const m = String(Math.floor(totalSeconds / 60)).padStart(2, "0"); const s = String(totalSeconds % 60).padStart(2, "0"); return `${m}:${s}`;}

function switchToCountdown(totalSeconds) {
  clearInterval(loadingInterval);
  const timerEl = document.getElementById("loading-timer");
  const elapsed = Math.floor((Date.now() - loadingStartTime) / 1000);
  let remaining = totalSeconds - elapsed;
  if (remaining < 0) remaining = 0;
  timerEl.textContent = formatMMSS(remaining);
  loadingInterval = setInterval(() => {
    remaining--;
    if (remaining < 0) {
      clearInterval(loadingInterval);
      timerEl.textContent = "00:00";
      return;
    }
    timerEl.textContent = formatMMSS(remaining);
  }, 1000);
}

async function analyzeFranchise(
  franchiseName,center,radius,numResults,threshold = 85,baseMetricsOverride = null) {
  currentAnalyzedFranchise = franchiseName;
  console.log('▶ analyzeFranchiseAsync:', { franchiseName, radius, numResults, threshold });

  const NSE_MIN_RELATIVE_RATIO = 0.3;

  analysisCircles.forEach(c => c.setMap(null));
  analysisMarkers.forEach(m => m.setMap(null));
  analysisCircles = [];
  analysisMarkers = [];

  const mainCircle = new google.maps.Circle({
    center, radius, map,
    strokeColor: '#FF6600', strokeOpacity: 0.7, strokeWeight: 2,
    fillColor: '#FFA500', fillOpacity: 0.1, zIndex: 3
  });
  analysisCircles.push(mainCircle);

  const baseMetrics = baseMetricsOverride || getMetrics(center, radius);
  const avgBaseRoad = baseMetrics.roadDists.length
    ? baseMetrics.roadDists.reduce((sum, r) => sum + r.dist, 0) / baseMetrics.roadDists.length
    : 0;
  const [bN1 = 'N/A', bN2 = 'N/A'] = baseMetrics.topNSEs;
  const bPerc1 = baseMetrics.totalVIV
    ? (baseMetrics.nseCounts[bN1] || 0) / baseMetrics.totalVIV
    : 0;
  const bPerc2 = baseMetrics.totalVIV
    ? (baseMetrics.nseCounts[bN2] || 0) / baseMetrics.totalVIV
    : 0;

  const baseTpl = `
    <div style="font-size:12px;line-height:1.3;">
      <strong>${franchiseName} (Original)</strong><br>
      NSE #1: ${bN1} (${(bPerc1*100).toFixed(1)}%)<br>
      NSE #2: ${bN2} (${(bPerc2*100).toFixed(1)}%)<br>
      Av1 (${baseMetrics.roadDists[0]?.name||'N/A'}): ${(baseMetrics.roadDists[0]?.dist/1000||0).toFixed(2)} km<br>
      Av2 (${baseMetrics.roadDists[1]?.name||'N/A'}): ${(baseMetrics.roadDists[1]?.dist/1000||0).toFixed(2)} km<br>
      Av3 (${baseMetrics.roadDists[2]?.name||'N/A'}): ${(baseMetrics.roadDists[2]?.dist/1000||0).toFixed(2)} km<br>
      Housing: ${baseMetrics.totalVIV}<br><br>
      vivScore: 100%<br>roadScore: 100%<br>nseScore: 100%<br>totalScore: 100%
    </div>`;
  const baseIw = new google.maps.InfoWindow({ content: baseTpl, position: center });
  mainCircle.addListener('click', () => baseIw.open(map));

  const gridCenter   = snapToGrid(center, GRID_SPACING);
  const grid         = generateGrid(gridCenter, GRID_RADIUS, GRID_SPACING);
  const brandMarkers = markers.filter(m => m.franchise === franchiseName);
  const empties      = grid.filter(pt =>
    brandMarkers.every(mk =>
      google.maps.geometry.spherical.computeDistanceBetween(mk.getPosition(), pt) >= 2 * radius
    )
  );
  const urbanEmpties = empties.filter(isUrban);

  console.log('– grid.total pts:', grid.length);
  console.log('– empties:', empties.length);
  console.log('– urbanEmpties:', urbanEmpties.length);

  const totalPoints = urbanEmpties.length;

  const t0 = Date.now();

  const scored = [];
  const CHUNK  = 50;
  for (let i = 0; i < totalPoints; i += CHUNK) {
    const slice = urbanEmpties.slice(i, i + CHUNK);
    slice.forEach(pt => {
      const m = getMetrics(pt, radius);
      m.topNSEs = [bN1, bN2];
      const cPerc1 = m.totalVIV ? (m.nseCounts[bN1] || 0) / m.totalVIV : 0;
      const cPerc2 = m.totalVIV ? (m.nseCounts[bN2] || 0) / m.totalVIV : 0;
      if (cPerc1 < bPerc1 * NSE_MIN_RELATIVE_RATIO || cPerc2 < bPerc2 * NSE_MIN_RELATIVE_RATIO)
        return;
      const vivScore = baseMetrics.totalVIV
        ? (m.totalVIV >= baseMetrics.totalVIV
            ? 100
            : 100 - Math.abs(baseMetrics.totalVIV - m.totalVIV) / baseMetrics.totalVIV * 100)
        : 100;
      const avgCandRoad = m.roadDists.length
        ? m.roadDists.reduce((sum, r) => sum + r.dist, 0) / m.roadDists.length
        : 0;
      const roadScore = (avgBaseRoad && avgCandRoad)
        ? Math.min(avgBaseRoad, avgCandRoad) / Math.max(avgBaseRoad, avgCandRoad) * 100
        : 0;
      const totalBasePerc = bPerc1 + bPerc2 || 1;
      const w1 = bPerc1 / totalBasePerc;
      const w2 = bPerc2 / totalBasePerc;
      const score1 = bPerc1 > 0 ? Math.min(cPerc1 / bPerc1, 1) : 0;
      const score2 = bPerc2 > 0 ? Math.min(cPerc2 / bPerc2, 1) : 0;
      const nseScore = (score1 * w1 + score2 * w2) * 100;
      const totalScore = Math.round(vivScore * 0.5 + nseScore * 0.3 + roadScore * 0.2);

      scored.push({ pt, m, vivScore, roadScore, nseScore, score: totalScore });
    });
    await new Promise(res => setTimeout(res, 0));
  }

  const elapsed = Date.now() - t0;
  avgMsPerPoint  = elapsed / totalPoints;

  console.log('– scored:', scored.map(s => s.score));

  const filtered = scored
    .filter(x => x.score >= threshold && x.m.totalVIV > 0)
    .sort((a, b) => {
      if (b.vivScore !== a.vivScore) return b.vivScore - a.vivScore;
      if (b.nseScore !== a.nseScore) return b.nseScore - a.nseScore;
      return b.roadScore - a.roadScore;
    });

const suggestions = [];
  for (const cand of filtered) {
    const ok = suggestions.every(sel =>
      google.maps.geometry.spherical.computeDistanceBetween(sel.pt, cand.pt) >= 2 * radius
    );
    if (ok) {
      suggestions.push(cand);
      if (suggestions.length >= numResults) break;
    }
  }
  console.log('– propuestas finales:', suggestions.map(s => s.score));
  showToast(`Analysis executed: ${suggestions.length} candidates found.`);

  suggestions.forEach(({ pt, m, vivScore, roadScore, nseScore, score }, idx) => {
    const [a1 = {}, a2 = {}, a3 = {}] = m.roadDists;
    const mk = new google.maps.Marker({
      position: pt,
      map,
      icon: {
        url: 'https://community.wacom.com/en-de/wp-content/uploads/sites/20/2023/10/Flame_GIF_1.gif',
        scaledSize: new google.maps.Size(64, 64),
        labelOrigin: new google.maps.Point(30, -10)
      },
      label: {
        text: `${score}%`,
        color: '#FFFFFF',
        fontWeight: 'bold',
        fontSize: '12px'
      },
      title: `#${idx + 1} – Match ${score}%`
    });
    analysisMarkers.push(mk);

    const circ = new google.maps.Circle({ center: pt, radius, map, strokeColor: '#ff6600', strokeOpacity: 0.85, strokeWeight: 3, fillColor: '#000000', fillOpacity: 0.5,clickable: false,zIndex: 3});
    analysisCircles.push(circ);

    const [n1 = 'N/A', n2 = 'N/A'] = m.topNSEs;
    const p1 = m.totalVIV ? (m.nseCounts[n1] || 0) / m.totalVIV : 0;
    const p2 = m.totalVIV ? (m.nseCounts[n2] || 0) / m.totalVIV : 0;
    const rel1 = bPerc1 > 0 ? Math.min(p1 / bPerc1, 2) * 100 : 0;
    const rel2 = bPerc2 > 0 ? Math.min(p2 / bPerc2, 2) * 100 : 0;
    const p1Display = (p1 * 100).toFixed(1);
    const p2Display = (p2 * 100).toFixed(1);

const tpl = `
  <div style="width:260px; padding:8px; font-size:12px; line-height:1.4;">
    <div style="text-align:center; font-size:14px; font-weight:bold; margin-bottom:6px;">
      Match: ${score}%
    </div>
    <hr style="margin:6px 0 10px 0;">

    <strong>Candidato #${idx + 1}</strong><br>
    Av1 (${a1.name || 'N/A'}): ${(a1?.dist ? (a1.dist / 1000).toFixed(2) : 'N/A')} km<br>
    Av2 (${a2.name || 'N/A'}): ${(a2?.dist ? (a2.dist / 1000).toFixed(2) : 'N/A')} km<br>
    Av3 (${a3.name || 'N/A'}): ${(a3?.dist ? (a3.dist / 1000).toFixed(2) : 'N/A')} km<br>
    Viviendas: ${m.totalVIV}

    <div style="margin-top:12px;">
      <strong style="display:block; margin-bottom:8px;">NSE comparativo vs base:</strong>

      <div style="display:flex; justify-content:space-around; align-items:center;">

        <!-- NSE 1 -->
        <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
          <div style="font-size:11px; margin-bottom:4px;">${n1}</div>
          <div style="display:flex; gap:4px; align-items:flex-end; height:80px; margin-bottom:4px;">
            <div title="Candidato" style="width:16px; background:#28a745; height:${p1Display*1.25}%;"></div>
            <div title="Base" style="width:16px; background:#888; height:${(bPerc1 * 100*1.25).toFixed(1)}%;"></div>
          </div>
          <div style="font-size:11px;">
            ${p1Display}% vs base ${(bPerc1 * 100).toFixed(1)}%
          </div>
        </div>

        <!-- NSE 2 -->
        <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
          <div style="font-size:11px; margin-bottom:4px;">${n2}</div>
          <div style="display:flex; gap:4px; align-items:flex-end; height:80px; margin-bottom:4px;">
            <div title="Candidato" style="width:16px; background:#28a745; height:${p2Display*1.25}%;"></div>
            <div title="Base" style="width:16px; background:#888; height:${(bPerc2 * 100*1.25).toFixed(1)}%;"></div>
          </div>
          <div style="font-size:11px;">
            ${p2Display}% vs base ${(bPerc2 * 100).toFixed(1)}%
          </div>
        </div>

      </div>
    </div>

    <hr style="margin:12px 0;">
    <div style="font-size:12px;">
      vivScore: ${vivScore.toFixed(1)}%<br>
      roadScore: ${roadScore.toFixed(1)}%<br>
      nseScore: ${nseScore.toFixed(1)}%<br>
      totalScore: ${score}%
    </div>
  </div>
`;

const iw = new google.maps.InfoWindow({ content: tpl });
mk.addListener('click', () => iw.open(map, mk));
  });


  return suggestions;
}


 async function runCustomAnalysis(pinMarker) {
  if (!baseFranchiseParams) {
    return alert("❗ Primero selecciona una franquicia base con “Establecer como base”.");
  }

  showLoading();

  const {
    franchiseName,
    radius,
    numResults,
    threshold,
    baseMetrics
  } = baseFranchiseParams;

  await analyzeFranchise(
    franchiseName,
    pinMarker.getPosition(),
    radius,
    numResults,
    threshold,
    baseMetrics
  );

  hideLoading();
}


let loadingStartTime;
let loadingInterval;

function showLoading() {
  const timerEl = document.getElementById("loading-timer");
  document.getElementById("loading-screen").style.display = "flex";
  loadingStartTime = Date.now();
  clearInterval(loadingInterval);
  switchToCountdown(60);
}

function hideLoading() {
  document.getElementById("loading-screen").style.display = "none";
  clearInterval(loadingInterval);
}

document.getElementById("export-research").addEventListener("click", () => {
 const storedPins     = JSON.parse(localStorage.getItem("researchPins")   || "[]");
 const customPins     = JSON.parse(localStorage.getItem("customPins")     || "[]");
 const importedKMZ    = JSON.parse(localStorage.getItem("importedKMZ")    || '{"pins":[],"polygons":[]}');
 const customPolygons = JSON.parse(localStorage.getItem("customPolygons") || "[]");
 const excelData      = JSON.parse(localStorage.getItem("excelData") || "{}");
 const rows           = Object.values(excelData).flat();


 const excelPins = [];
 const excelPolygons = [];


 rows.forEach(row => {
   const lat = row.position?.lat ?? row.lat ?? row.Lat ?? row.latitude ?? row.Latitude;
   const lng = row.position?.lng ?? row.lng ?? row.Lng ?? row.longitude ?? row.Longitude;


   if (!isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng))) {
     excelPins.push({
       name: row.name || row.Name || row.location || row.Location || "",
       position: { lat: parseFloat(lat), lng: parseFloat(lng) },
       icon: row.icon || {}
     });
     return;
   }


   const paths = row.paths || row.Paths || row.path || row.coordinates;
   if (Array.isArray(paths) && paths.length > 2 && paths[0].lat !== undefined && paths[0].lng !== undefined) {
     excelPolygons.push({
       name: row.name || row.Name || "Polygon",
       paths
     });
     return;
   }


   if (row.WKT || row.wkt) {
     const wkt = row.WKT || row.wkt;
     excelPolygons.push({
       name: row.name || row.Name || "Polygon",
       wkt
     });
   }
 });

if ( storedPins.length === 0 && excelPins.length === 0 && customPins.length === 0 && importedKMZ.pins.length === 0 && customPolygons.length === 0 && excelPolygons.length === 0 && importedKMZ.polygons.length === 0) {
   return alert("Can't Download Empty Files!");
 }

const workbook = XLSX.utils.book_new();

if (storedPins.length) {
   const ws1 = XLSX.utils.json_to_sheet(storedPins);
   XLSX.utils.book_append_sheet(workbook, ws1, "Research");
 }

 const allPins = [...excelPins,...customPins.map(p => ({name: p.name || "",position: { lat: p.position.lat, lng: p.position.lng },icon: p.icon || {}})),...importedKMZ.pins.map(p => ({name: p.name || "",position: { lat: p.position.lat, lng: p.position.lng },icon: p.icon || {}})) ];
if (allPins.length) { const sheetData = allPins.map(p => ({name: p.name,lat:  p.position.lat,lng:  p.position.lng,icon: JSON.stringify(p.icon)}));

const wsPins = XLSX.utils.json_to_sheet(sheetData); XLSX.utils.book_append_sheet(workbook, wsPins, "Markers");}
const customPolys = customPolygons.map(p => ({ name: p.name || p.paths?.name || "",paths: Array.isArray(p.paths) ? p.paths : Array.isArray(p.paths?.paths) ? p.paths.paths : []}));
const importedPolys = importedKMZ.polygons.map(p => ({ name: p.name || "", paths: Array.isArray(p.paths) ? p.paths : Array.isArray(p.paths?.paths) ? p.paths.paths : []}));
const excelPolys = excelPolygons.map(p => { if (p.paths) { return { name: p.name, paths: p.paths };} else if (p.wkt) {return { name: p.name, wkt: p.wkt }; } return null;}).filter(p => p !== null);
const allPolys = [...customPolys, ...importedPolys, ...excelPolys];

if (allPolys.length > 0) { const wktRows = [["name", "WKT"]]; allPolys.forEach(({ name, paths, wkt }) => { if (wkt) {wktRows.push([name, wkt]);} else if (Array.isArray(paths) && paths.length > 2) { const coords = paths.map(pt => `${pt.lng} ${pt.lat}`); if (coords[0] !== coords[coords.length - 1]) coords.push(coords[0]); const wktString = `POLYGON((${coords.join(", ")}))`; wktRows.push([name, wktString]);}});
if (wktRows.length > 1) { const wsPolys = XLSX.utils.aoa_to_sheet(wktRows); XLSX.utils.book_append_sheet(workbook, wsPolys, "Polygons");}}

const fileName = prompt("Enter the name for the Excel file:", "Market Spots Geodata"); if (!fileName) return alert("Export cancelled."); XLSX.writeFile(workbook, `${fileName}.xlsx`);});

const SHEET_CITY_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vSnCE6UL7mfg1wEGDaUj5x5FFnebN5QG8zihbtEWvx7XBtdrnfsqbxY3a4X5-x2SeAiadca9B9jp9dp/pub?gid=0&single=true&output=csv";

const SHEET_POLYGON_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vSnCE6UL7mfg1wEGDaUj5x5FFnebN5QG8zihbtEWvx7XBtdrnfsqbxY3a4X5-x2SeAiadca9B9jp9dp/pub?gid=1002889666&single=true&output=csv";

document.addEventListener('DOMContentLoaded', () => {
  const btn   = document.getElementById('city-options');
  const panel = document.getElementById('city-options-panel');
  panel.style.display = 'none';

  btn.addEventListener('click', e => {
    e.stopPropagation();
    panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
  });

  document.addEventListener('click', e => {
    if (!panel.contains(e.target) && !btn.contains(e.target)) {
      panel.style.display = 'none';
    }
  });

  // ———————————— Checkbox ↔ Categoría ————————————
  const idToCategory = {
    'opt-airports':       'Airports',
    'opt-audience':       'Audience & Concerts Venues',
    'opt-evcs':           'Electric Vehicles Charging Stations',
    'opt-public-parks':   'Public Parks',
    'opt-schools':        'Universities & Highschools',
    'opt-stadiums':       'Sport Stadiums',
    'opt-urbantrain':     'Urban Train Stations'
  };

  const markersByCategory  = {};
  const polygonsByCategory = {};

  Object.keys(idToCategory).forEach(id => {
    const cb = document.getElementById(id);
    cb.checked = false;
    cb.addEventListener('change', () => {
      const cat = idToCategory[id];
      const visible = cb.checked;

      // Mostrar/Ocultar markers
      (markersByCategory[cat] || []).forEach(m => m.setVisible(visible));

      // Mostrar/Ocultar polígonos
      (polygonsByCategory[cat] || []).forEach(p => p.setMap(visible ? map : null));
    });
  });

  // ———————————— Cargar MARKERS ————————————
  Papa.parse(SHEET_CITY_URL, {
    download: true,
    header:   true,
    complete: results => {
      console.log('Markers found in City Elements:', results.data.length);
      results.data.forEach(row => {
        const lat = parseFloat(row.lat);
        const lng = parseFloat(row.lng);
        if (isNaN(lat) || isNaN(lng)) return;

        const cat = row.category;
        if (!Object.values(idToCategory).includes(cat)) return;

        const marker = new google.maps.Marker({
          position: { lat, lng },
          map,
          title: row.name,
          icon: {
            url: row.icon,
            scaledSize: new google.maps.Size(32, 34)
          }
        });
        marker.setVisible(false);

        markersByCategory[cat] = markersByCategory[cat] || [];
        markersByCategory[cat].push(marker);
      });
    },
    error: err => console.error('Error cargando CSV de markers:', err)
  });

  // ———————————— Cargar POLÍGONOS ————————————
  Papa.parse(SHEET_POLYGON_URL, {
    download: true,
    header:   true,
    complete: results => {
      console.log('Polygons found in City Elements:', results.data.length);
      results.data.forEach(row => {
        const cat = row.category;
        const wkt = row.wkt;

        if (!Object.values(idToCategory).includes(cat)) return;
        if (!wkt || !wkt.startsWith("POLYGON")) return;

        const polygonPaths = parseWKTPolygon(wkt);
        if (!polygonPaths) return;

const color = row.color || "#FF6600";
const name  = row.name || "Polígono sin nombre";

const polygon = new google.maps.Polygon({
  paths: polygonPaths,
  strokeColor: color,
  strokeOpacity: 0.8,
  strokeWeight: 2,
  fillColor: color,
  fillOpacity: 0.35,
  map: null
});

// Calcular área y guardar en customData
const area = google.maps.geometry.spherical.computeArea(polygon.getPath());
polygon.customData = { name, area };

// Aplicar tooltip
applyPolygonTooltip(polygon, name);

// Guardar referencia
polygonsByCategory[cat] = polygonsByCategory[cat] || [];
polygonsByCategory[cat].push(polygon);
      });
    },
    error: err => console.error('Error cargando CSV de polígonos:', err)
  });

  // ———————————— Función para convertir WKT a paths ————————————
  function parseWKTPolygon(wkt) {
    try {
      const coords = wkt
        .replace("POLYGON((", "")
        .replace("))", "")
        .split(",")
        .map(pair => {
          const [lng, lat] = pair.trim().split(" ").map(Number);
          return { lat, lng };
        });
      return [coords]; // Google Maps espera un array de paths
    } catch (e) {
      console.warn("❌ WKT inválido:", wkt);
      return null;
    }
  }
});

async function sendResearchPins() {
  const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyocSiZdvBd9AcyNdxV_7Idhbr52z6Uo_5ShEN7m5ZN8Lf0wGmBCsOV2rqDUIRgO281Xg/exec';
  
  const data = JSON.parse(localStorage.getItem('researchPins') || '[]');

  if (!Array.isArray(data) || data.length === 0) {
    alert('No hay registros en localStorage.researchPins');
    return;
  }

  // Valida que TODO ya venga como número y en rango
  const bad = data.filter(p =>
    typeof p.Latitude !== 'number' || !Number.isFinite(p.Latitude) ||
    typeof p.Longitude !== 'number' || !Number.isFinite(p.Longitude) ||
    p.Latitude < -90 || p.Latitude > 90 || p.Longitude < -180 || p.Longitude > 180
  );

  if (bad.length) {
    console.warn('[SEND] registros inválidos (no se enviarán):', bad.slice(0,10));
    alert(`Hay ${bad.length} registro(s) inválido(s) en researchPins. Revisa la consola.`);
    // Si quieres abortar aquí:
    // return;
  }

  // Mapea solo lo necesario (6 columnas)
const mapped = data.map(p => {
  // tolerante: toma lat/lng de varias posibles formas y conviértelas a número
  const lat = (typeof p.Latitude === 'number') ? p.Latitude
            : (p.position && typeof p.position.lat === 'number') ? p.position.lat
            : Number(String(p.Latitude ?? p.lat ?? '').replace(',', '.'));

  const lng = (typeof p.Longitude === 'number') ? p.Longitude
            : (p.position && typeof p.position.lng === 'number') ? p.position.lng
            : Number(String(p.Longitude ?? p.lng ?? '').replace(',', '.'));

  return {
    Franchise:  String(p?.Franchise ?? ''),
    Operations: String(p?.Operations ?? ''),
    Address:    String(p?.Address ?? ''),
    Location:   String(p?.Location ?? ''),
    Latitude:   lat,
    Longitude:  lng
  };
});

  console.table(mapped.slice(0,10).map(r => ({
    Franchise: r.Franchise, Latitude: r.Latitude, Longitude: r.Longitude,
    lat_type: typeof r.Latitude, lng_type: typeof r.Longitude
  })));

  try {
    await fetch(WEB_APP_URL, {
      method: 'POST',
      mode: 'no-cors',
      headers: { 'Content-Type': 'text/plain;charset=utf-8' },
      body: JSON.stringify(mapped)
    });
    alert(`Enviados ${mapped.length} registro(s).`);
    localStorage.removeItem("researchPins");
  } catch (e) {
    console.error(e);
    alert('Error al enviar: ' + e.message);
  }
}


///////////////////////////////////////////////////////// Inicia Exportación a KMZ ///////////////////////////////////////////////////////////////////////////

// 🎯 Asociar al botón
document.getElementById("exportKmzBtn").addEventListener("click", exportToKMZ);

/**
 * Convierte un array de coords [{lat,lng},…] en un <Placemark> KML de tipo POLYGON,
 * usando el nombre que se le pase.
 */
function polygonToKml(name, pathArray) {
  if (!Array.isArray(pathArray) || pathArray.length < 3) return "";
  // Lon,Lat,0
  const coords = pathArray.map(p => `${p.lng},${p.lat},0`);
  // Cerramos el anillo
  if (coords[0] !== coords[coords.length - 1]) {
    coords.push(coords[0]);
  }
  return `
    <Placemark>
      <name>${name}</name>
      <Style>
        <!-- stroke FF6600 (opaco) -->
        <LineStyle>
          <color>ff0066ff</color>
          <width>2</width>
        </LineStyle>
        <!-- fill 000000 al 25% → alpha=40 hex -->
        <PolyStyle>
          <color>40000000</color>
        </PolyStyle>
      </Style>
      <Polygon>
        <outerBoundaryIs>
          <LinearRing>
            <coordinates>${coords.join(" ")}</coordinates>
          </LinearRing>
        </outerBoundaryIs>
      </Polygon>
    </Placemark>`;
}

/**
 * Lee todos los pines y polígonos de localStorage y genera un KMZ válido para Google Earth.
 */
function exportToKMZ() {
    // 1) Recoger de localStorage
    const customPins     = JSON.parse(localStorage.getItem("customPins"))     || [];
    const researchPins   = JSON.parse(localStorage.getItem("researchPins"))   || [];
    const importedKMZ    = JSON.parse(localStorage.getItem("importedKMZ"))    || { pins: [], polygons: [] };
    const customPolygons = JSON.parse(localStorage.getItem("customPolygons")) || [];
    const excelPins      = JSON.parse(localStorage.getItem("excelData"))      || [];
  
    // 2) Verificar que haya algo que exportar
    const hasPins  = customPins.length > 0
                   || researchPins.length > 0
                   || importedKMZ.pins.length > 0
                   || excelPins.length > 0;
    const hasPolys = customPolygons.length > 0
                   || importedKMZ.polygons.length > 0;
    if (!hasPins && !hasPolys) {
      alert("No Data to Download");
      return;
    }
  
    // 3) Nombre del archivo
    const fileName = prompt("Introduzca el nombre del KMZ:", "market_spot");
    if (!fileName) {
      alert("Exportación cancelada.");
      return;
    }
  
    // 4) Construir KML de todos los pines (incluye excelPins)
    const allPins = [
      ...customPins,
      ...researchPins,
      ...importedKMZ.pins,
      ...excelPins      // <— añadimos aquí
    ];
    
    const pinKml = allPins.map(p => {
      const name    = p.name || "Pin";
      const lat     = parseFloat(p.position?.lat);
      const lng     = parseFloat(p.position?.lng);
      const iconUrl = p.icon?.url || p.iconUrl;
    
      // Asumimos iconos de 30×30px, así que el scale es 30/30 = 1
      const scale = 1;                   // ajustar escala si quieres
    
      if (isNaN(lat) || isNaN(lng)) return "";
    
      // construimos el bloque <Style> solo si hay icono
      const styleKml = iconUrl ? `
        <Style>
          <IconStyle>
            <scale>${scale}</scale>
            <Icon>
              <href>${iconUrl}</href>
            </Icon>
          </IconStyle>
        </Style>
      ` : "";
    
      return `
        <Placemark>
          <name>${name}</name>
          ${styleKml}
          <Point>
            <coordinates>${lng},${lat},0</coordinates>
          </Point>
        </Placemark>
      `;
    }).join("\n");
  
    // 5) Construir KML de todos los polígonos
    const allPolysRaw = [
      ...customPolygons.map(p => ({ name: p.name || "Polygon", paths: p.paths })),
      ...importedKMZ.polygons
    ];
    const polygonKml = allPolysRaw.map(p => polygonToKml(p.name, p.paths)).join("\n");
  
    // 6) Montar KML completo
    const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
    <kml xmlns="http://www.opengis.net/kml/2.2">
      <Document>
        <name>${fileName}</name>
        ${pinKml}
        ${polygonKml}
      </Document>
    </kml>`;
  
    console.log("🛰️ KML generado:\n", kmlContent);
  
    // 7) Empaquetar en KMZ con JSZip
    const zip = new JSZip();
    zip.file("doc.kml", kmlContent);
    zip.generateAsync({ type: "blob" }).then(blob => {
      const url = URL.createObjectURL(blob);
      const a   = document.createElement("a");
      a.href        = url;
      a.download    = `${fileName}.kmz`;
      a.click();
      URL.revokeObjectURL(url);
    });
  }

///////////////////////////////////////////////////////// Load KMZ Files (sin InfoWindow) ///////////////////////////////////////////////////////////////////////////



// Botón para seleccionar archivo KMZ
document.getElementById("kmz-trigger").addEventListener("click", () => {
  document.getElementById("kmz-input").click();
});

document.getElementById("kmz-input").addEventListener("change", function (event) {
  const file = event.target.files[0];
  if (!file) return;

  document.getElementById("import-files-panel").style.display = "none";
  const reader = new FileReader();

  reader.onload = e => {
    JSZip.loadAsync(e.target.result).then(zip => {
      const kmlFile = Object.keys(zip.files).find(n => n.endsWith(".kml"));
      if (!kmlFile) {
        alert("No .kml en el KMZ.");
        return;
      }
      zip.files[kmlFile].async("string").then(kmlText => {
        new geoXML3.parser({
          map: map,
          markerOptions: { clickable: true },
          afterParse: docs => {
            // 1) Inicializar arrays de storage
            const stored    = JSON.parse(localStorage.getItem("importedKMZ") || '{"pins":[],"polygons":[]}');
            const pins      = [];  // siempre vacíos para recarga completa
            const polygons  = [];

            // 2) Limpia viejos overlays
            (window.importedMarkers  || []).forEach(m => m.setMap(null));
            (window.importedPolygons || []).forEach(p => p.setMap(null));
            window.importedMarkers  = [];
            window.importedPolygons = [];

            const tooltipOverlay = new google.maps.OverlayView();
            tooltipOverlay.onAdd = () => {};
            tooltipOverlay.draw  = () => {};
            tooltipOverlay.setMap(map);
            const tooltipDiv = document.getElementById("tooltip");

            // 3) Procesa cada doc
            docs.forEach(doc => {
              // — Pines generados por geoXML3 —
              (doc.markers || []).forEach(gmarker => {
                window.importedMarkers.push(gmarker);
                google.maps.event.clearListeners(gmarker, 'click');
    

                // Extraer URL si existe
                let iconUrl = null;
                const ico = gmarker.getIcon();
                if (typeof ico === 'string') {
                  iconUrl = ico;
                } else if (ico && ico.url) {
                  iconUrl = ico.url;
                }
                
                // Si encontraste un icono en el KML, asígnaselo al marker con scaledSize 30×30
                if (iconUrl) {
                  gmarker.setIcon({
                    url:        iconUrl,
                    // fuerza 30px ancho × 30px alto
                    scaledSize: new google.maps.Size(30, 30)
                  });
                }

                pins.push({
                  name:     gmarker.getTitle(),
                  position: {
                    lat: gmarker.getPosition().lat(),
                    lng: gmarker.getPosition().lng()
                  },
                  iconUrl  // string o null
                });

                gmarker.addListener("click", () => {
                  const title = gmarker.getTitle();
                  if (!confirm(`Delete Marker "${title}"?`)) return;
              
                  // 1) Quitar del mapa
                  gmarker.setMap(null);
              
                  // 2) Quitar de tu array en memoria
                  window.importedMarkers = window.importedMarkers.filter(m => m !== gmarker);
              
                  // 3) Reescribir storage con los pins que quedan
                  const stored = JSON.parse(localStorage.getItem("importedKMZ") || '{"pins":[],"polygons":[]}');
                  stored.pins = window.importedMarkers.map(m => ({
                    name:     m.getTitle(),
                    position: {
                      lat: m.getPosition().lat(),
                      lng: m.getPosition().lng()
                    },
                    iconUrl: m.getIcon() && (typeof m.getIcon() === 'string' ? m.getIcon() : m.getIcon().url)
                  }));
                  localStorage.setItem("importedKMZ", JSON.stringify(stored));
                });

              });

// — Polígonos —
(doc.placemarks || []).forEach(pm => {
  if (!pm.polygon) return;
  const poly = pm.polygon;
  const name = pm.name || "Polygon";
  const path = poly.getPath().getArray().map(p => ({
    lat: p.lat(), lng: p.lng()
  }));

  // ✅ Guardar con estilos originales
  polygons.push({
    name,
    paths:         path,
    strokeColor:   poly.strokeColor   || poly.get("strokeColor"),
    strokeOpacity: poly.strokeOpacity || poly.get("strokeOpacity"),
    strokeWeight:  poly.strokeWeight  || poly.get("strokeWeight"),
    fillColor:     poly.fillColor     || poly.get("fillColor"),
    fillOpacity:   poly.fillOpacity   || poly.get("fillOpacity"),
    clickable:     poly.get("clickable"),
    zIndex:        poly.get("zIndex") ?? 98
  });

  // ✅ Mostrar sin sobrescribir estilo
  poly.setMap(map);
  window.importedPolygons.push(poly);
  google.maps.event.clearListeners(poly, 'click');


// Tooltip en polígonos
poly.addListener("mouseover", () => {
  const area = google.maps.geometry.spherical.computeArea(poly.getPath());
  const formattedArea = area.toLocaleString(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
  tooltipDiv.innerHTML = `<strong>${name}</strong><br>${formattedArea} m²`;
  tooltipDiv.style.display = "block";
});
poly.addListener("mousemove", e => {
  const proj = tooltipOverlay.getProjection();
  const pos  = proj.fromLatLngToDivPixel(e.latLng);
  tooltipDiv.style.left = pos.x + "px";
  tooltipDiv.style.top  = pos.y + "px";
});
poly.addListener("mouseout", () => {
  tooltipDiv.style.display = "none";
});


poly.addListener("click", () => {
  if (!confirm(`Delete Polygon "${name}"?`)) return;

  

  // 1) Quitar del mapa
  poly.setMap(null);

  // 2) Quitar de tu array en memoria
  window.importedPolygons = window.importedPolygons.filter(p => p !== poly);

  // 3) Reescribir localStorage solo con los que quedan
  const stored = { 
    pins: JSON.parse(localStorage.getItem("importedKMZ")).pins,
    polygons: window.importedPolygons.map(pg => ({
      name:        pg.__name,
      paths:       pg.getPath().getArray().map(c => ({ lat: c.lat(), lng: c.lng() })),
      strokeColor: pg.get("strokeColor"),
      fillColor:   pg.get("fillColor"),
      fillOpacity: pg.get("fillOpacity"),
      clickable:   pg.get("clickable"),
      zIndex:      pg.get("zIndex")
    }))
  };
  localStorage.setItem("importedKMZ", JSON.stringify(stored));
});

              });
            });

            // 4) Guardar siempre objetos serializables
            localStorage.setItem(
              "importedKMZ",
              JSON.stringify({ pins, polygons })
            );
            playSound("sounds/polygon.mp3");

            // 5) Centrar mapa
            const bounds = new google.maps.LatLngBounds();
            window.importedMarkers.forEach(m => bounds.extend(m.getPosition()));
            window.importedPolygons.forEach(poly =>
              poly.getPath().getArray().forEach(pt => bounds.extend(pt))
            );
            map.fitBounds(bounds);
          }
        }).parseKmlString(kmlText);
      });
    });
  };

  reader.readAsArrayBuffer(file);
});

// Para renderizar de nuevo desde storage (p.e. en init)
function renderImportedKMZ() {
  const imported = JSON.parse(
    localStorage.getItem("importedKMZ") ||
    '{"pins":[],"polygons":[]}'
  );

  // Limpiar previos
  (window.importedMarkers  || []).forEach(m => m.setMap(null));
  (window.importedPolygons || []).forEach(p => p.setMap(null));
  window.importedMarkers  = [];
  window.importedPolygons = [];

  // Pines
  imported.pins.forEach(pin => {
    const opts = {
      position: pin.position,
      title:    pin.name,
      map
    };
    if (pin.iconUrl) opts.icon = pin.iconUrl;
    const m = new google.maps.Marker(opts);
    window.importedMarkers.push(m);
  });

  // Polígonos
  imported.polygons.forEach(poly => {
    const p = new google.maps.Polygon({
      paths:         poly.paths,
      strokeColor:   poly.strokeColor,
      strokeOpacity: poly.strokeOpacity,
      strokeWeight:  poly.strokeWeight,
      fillColor:     poly.fillColor,
      fillOpacity:   poly.fillOpacity,
      clickable:     poly.clickable,
      zIndex:        poly.zIndex,
      map
    });
    window.importedPolygons.push(p);
  });
}



function applyPolygonTooltip(polygon, label, extraHtmlFn) {
  polygon.addListener("mouseover", e => {
    const html = extraHtmlFn
      ? `${label}<br>${extraHtmlFn(polygon)}`
      : label;
    tooltipDiv.innerHTML    = html;
    const pos = tooltipOverlay
      .getProjection()
      .fromLatLngToDivPixel(e.latLng);
    tooltipDiv.style.left   = pos.x + "px";
    tooltipDiv.style.top    = pos.y + "px";
    tooltipDiv.style.display= "block";
  });
  polygon.addListener("mousemove", e => {
    const pos = tooltipOverlay
      .getProjection()
      .fromLatLngToDivPixel(e.latLng);
    tooltipDiv.style.left = pos.x + "px";
    tooltipDiv.style.top  = pos.y + "px";
  });
  polygon.addListener("mouseout", () => {
    tooltipDiv.style.display = "none";
  });
}



async function exportAnalysis(data) {
  const password = "MarketSpots2025";

  // 1) Leer y serializar custom pins y polígonos definidos por el usuario
  const customPins = JSON.parse(localStorage.getItem("customPins") || "[]");
  const customPolygons = JSON.parse(localStorage.getItem("customPolygons") || "[]");

// 2) Serializar los datos importados (MKTS)
//   Reutilizamos directamente lo que ya guardaste al cargar el KMZ
const storedKMZ = JSON.parse(
  localStorage.getItem("importedKMZ") || '{"pins":[],"polygons":[]}'
);

// a) Pines importados
const serializedPins = (storedKMZ.pins || []).map(pin => ({
  name:     pin.name     || "",
  position: pin.position || {lat:0,lng:0},
  iconUrl:  pin.iconUrl  || null
}));

// b) Polígonos importados
const serializedPolygons = (storedKMZ.polygons || []).map(poly => ({
  name:         poly.name         || "",
  paths:        poly.paths        || [], 
  strokeColor:  poly.strokeColor  || "#000000",
  strokeOpacity:poly.strokeOpacity|| 1.0,
  strokeWeight: poly.strokeWeight || 2,
  fillColor:    poly.fillColor    || "#000000",
  fillOpacity:  poly.fillOpacity  || 0.5,
  // si guardaste area en el KMZ import original, úsalo; si no, lo recalculas
  area:         poly.area != null
                  ? poly.area
                  : parseFloat(
                      google.maps.geometry.spherical
                        .computeArea(poly.paths.map(p=>new google.maps.LatLng(p.lat,p.lng)))
                        .toFixed(2)
                    )
}));

const serializedKMZ = {
  pins:     serializedPins,
  polygons: serializedPolygons
};

  // 3) Inyectar al objeto data antes de cifrar
  data.customPins     = customPins;
  data.customPolygons = customPolygons;
  data.importedKMZ    = serializedKMZ;


    // 3bis) Incluir la posición actual del mapa
  data.center = map.getCenter().toJSON();  // { lat: ..., lng: ... }
  data.zoom   = map.getZoom();

  // ---------------------------------------------------------------------------
  // Añadir selección de estados y municipios al análisis antes de cifrar
  // Esto permite que los archivos MKTS incluyan los estados y municipios
  // activados por el usuario en el panel de "City Limits" (municipios-panel).
  // Si no existen selecciones o el panel no está construido, no añadirá nada.
  try {
    const { selectedStates, selectedMunicipios } = gatherSelectedMunicipios();
    if (selectedStates && selectedStates.length > 0) {
      data.selectedStates = selectedStates;
    }
    if (selectedMunicipios && selectedMunicipios.length > 0) {
      data.selectedMunicipios = selectedMunicipios;
    }
  } catch (err) {
    console.warn('No se pudieron capturar los estados/municipios seleccionados:', err);
  }

  // 4) Configurar cifrado AES-GCM con PBKDF2
  const enc = new TextEncoder();
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );
  const key = await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: enc.encode("marketspots-salt"),
      iterations: 150000,
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );

  // 5) Cifrar el JSON de data
  const encodedData = enc.encode(JSON.stringify(data));
  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    encodedData
  );

  // 6) Generar y descargar el archivo .mkts
  const blob = new Blob([iv, new Uint8Array(encrypted)], {
    type: "application/octet-stream"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const fileNameInput = document.getElementById("filename-input");
  const finalName = fileNameInput?.value?.trim() || `marketspot_${Date.now()}`;
  a.download = `${finalName}.mkts`;
  a.click();
  URL.revokeObjectURL(url);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

async function importAnalysis(file, onDataLoaded) {
  const reader = new FileReader();
  reader.onload = async function () {
    const buffer = reader.result;
    const iv = buffer.slice(0, 12);
    const data = buffer.slice(12);
    try {
      const password = "MarketSpots2025";
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        "raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]
      );
      const key = await crypto.subtle.deriveKey({
        name: "PBKDF2",
        salt: enc.encode("marketspots-salt"),
        iterations: 150000,
        hash: "SHA-256"
      }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["decrypt"]);
      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: new Uint8Array(iv) },
        key,
        data
      );
      const json = JSON.parse(new TextDecoder().decode(decrypted));

      // -------------------------------------------------------------------------
      // Restaurar selección de estados y municipios.
      // Guardamos en localStorage para que el panel de municipios lea las
      // selecciones cuando se vuelva a cargar. Además intentamos restaurar
      // inmediatamente los checkboxes si ya existen en el DOM.
      if (json.selectedStates) {
        try {
          localStorage.setItem('selectedStates', JSON.stringify(json.selectedStates));
        } catch (_) {}
      }
      if (json.selectedMunicipios) {
        try {
          localStorage.setItem('selectedMunicipios', JSON.stringify(json.selectedMunicipios));
        } catch (_) {}
      }
      if (typeof restoreSelectedMunicipios === 'function' && json.selectedMunicipios) {
        // Restaurar después de un pequeño retardo para asegurar que la UI esté lista
        setTimeout(() => restoreSelectedMunicipios(json.selectedMunicipios), 500);
      }

      // 1) Limpiar cualquier importación previa de MKTS
      if (window.importedKMZPolygons) {
        window.importedKMZPolygons.forEach(p => p.setMap(null));
      }
      window.importedKMZPolygons = [];

      // 2) Limpiar regla previa y ocultar su popup
      if (window.rulerPolyline) {
        window.rulerPolyline.setMap(null);
        window.rulerPolyline = null;
      }
      const popup = document.getElementById("ruler-popup");
      if (popup) popup.style.display = "none";

      // 3) Restaurar custom pins
      if (json.customPins) {
        localStorage.setItem("customPins", JSON.stringify(json.customPins));
        loadLocalPins();
      }

      // 4) Restaurar custom polygons
      if (json.customPolygons) {
        localStorage.setItem("customPolygons", JSON.stringify(json.customPolygons));
        if (typeof loadLocalPolygons === "function") {
          loadLocalPolygons();
        }
      }

      // 5) Restaurar importedKMZ (polígonos importados)
      if (json.importedKMZ) {
        localStorage.setItem("importedKMZ", JSON.stringify(json.importedKMZ));
      }

      // 6) Llamar al callback para que el mapa restaure filtros, centro, polígonos y regla
      onDataLoaded(json);
    } catch (e) {
      showToast("No se pudo leer el archivo.");
      console.error(e);
    }
  };
  reader.readAsArrayBuffer(file);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

function applyPolygonTooltip(polygon, label, extraHtmlFn) {
  const fmt = new Intl.NumberFormat(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });

  // Función por defecto: calcula el área al vuelo
  const htmlFn = typeof extraHtmlFn === "function"
    ? extraHtmlFn
    : p => {
        const a = google.maps.geometry.spherical.computeArea(p.getPath());
        return `${fmt.format(a)} m²`;
      };

  polygon.addListener("mouseover", () => {
    tooltipDiv.innerHTML = `<strong>${label}</strong><br>${htmlFn(polygon)}`;
    tooltipDiv.style.display = "block";
  });
  polygon.addListener("mousemove", e => {
    const pos = tooltipOverlay.getProjection().fromLatLngToDivPixel(e.latLng);
    tooltipDiv.style.left = pos.x + "px";
    tooltipDiv.style.top  = pos.y + "px";
  });
  polygon.addListener("mouseout", () => {
    tooltipDiv.style.display = "none";
  });
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

async function triggerImport() {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".mkts";
  input.onchange = () => {
    const file = input.files[0];
    if (!file) return;

    importAnalysis(file, (loadedData) => {
  try {
    // — antes de cualquier creación de círculos o polígonos —
    if (loadedData.center) {
      map.setCenter(loadedData.center);
    }
    if (loadedData.zoom != null) {
      map.setZoom(loadedData.zoom);
    }

    // 1) Desempaquetar datos restaurados
    const {
      center,       // ya no lo usaremos aquí para el círculo
      radius,
      pins,
      filters,
      customPins,
      customPolygons
    } = loadedData;

        // 2) Restaurar círculo
        if (currentCircle) {
          currentCircle.setMap(null);
          currentCircle = null;
        }
        let circle = null;
        if (center && radius) {
          circle = new google.maps.Circle({
            map,
            center,
            radius,
            fillColor:   "#000000",
            fillOpacity: 0.25,
            strokeColor: "#FF0000",
            strokeWeight: 5,
            clickable:   false,
            editable:    false,
            zIndex:      100
          });
          currentCircle = circle;
        }

        // 3) Restaurar regla y popup de distancia
        if (loadedData.rulerLine) {
          const { pointA, pointB } = loadedData.rulerLine;
          if (rulerPolyline) {
            rulerPolyline.setMap(null);
          }
          const linePath = [
            new google.maps.LatLng(pointA.lat, pointA.lng),
            new google.maps.LatLng(pointB.lat, pointB.lng)
          ];
          rulerPolyline = new google.maps.Polyline({
            path:       linePath,
            geodesic:   true,
            strokeColor:"#ff6600",
            strokeOpacity: 1.0,
            strokeWeight: 4,
            map,
            zIndex:     100
          });

          const popup     = document.getElementById("ruler-popup");
          const popupText = document.getElementById("ruler-popup-text");
          const distMeters = google.maps.geometry.spherical.computeDistanceBetween(
            new google.maps.LatLng(pointA.lat, pointA.lng),
            new google.maps.LatLng(pointB.lat, pointB.lng)
          );
          const formatted = distMeters >= 1000
            ? (distMeters / 1000).toFixed(2) + " km"
            : Math.round(distMeters) + " m";
          popupText.textContent = formatted;
          popup.style.display   = "block";
        }

        // 4) Restaurar filtros NSE
        activeNSEs = new Set(filters.nse || []);
        document.querySelectorAll("#nse-control-content input[type=checkbox]")
          .forEach(cb => {
            const value = cb.nextSibling?.textContent?.trim();
            cb.checked = activeNSEs.has(value);
            (nsePolygons[value] || []).forEach(poly =>
              poly.setMap(cb.checked ? map : null)
            );
          });

        // 5) Restaurar clasificación Retail
        const ops = Array.isArray(filters.operations) ? filters.operations : [];
        activeOperations = new Set(ops);
        document.querySelectorAll("#operations-control-content input[type=checkbox]")
          .forEach(cb => {
            const label = cb.nextSibling?.textContent?.trim() || cb.value;
            const checked = ops.includes(label);
            cb.checked = checked;
            if (checked) cb.dispatchEvent(new Event("change"));
          });

        // 6) Restaurar Locations
        activeLocationsFilter = new Set(filters.locations || []);
        document.querySelectorAll("#location-filter-content input[type=checkbox]")
          .forEach(cb => {
            const loc = cb.value;
            cb.checked = activeLocationsFilter.has(loc);
            if (cb.checked) cb.dispatchEvent(new Event("change"));
          });

        // 7) Restaurar City Boundaries
        activeLocations = new Set(filters.cityBoundaries || []);
        isRestoringCityBoundaries = true;
        document.querySelectorAll("#location-control-content input[type=checkbox]")
          .forEach(cb => {
            const city = cb.nextSibling?.textContent?.trim();
            cb.checked = activeLocations.has(city);
            if (cb.checked) cb.dispatchEvent(new Event("change"));
          });
        isRestoringCityBoundaries = false;

        // 8) Restaurar Avenues
        activeAvenues = new Set(filters.traffic || []);
        document.querySelectorAll("#avenue-control-content input[type=checkbox]")
          .forEach(cb => {
            const label = cb.parentNode?.textContent?.trim();
            if (!label || cb.classList.contains("summary-checkbox")) return;
            cb.checked = activeAvenues.has(label);
            if (cb.checked) cb.dispatchEvent(new Event("change"));
          });

        // 9) Restaurar visibilidad de markers según filtro de franquicias
        markers.forEach(marker => {
          marker.__visibleByFranchise = filters.franchises.includes(marker.franchise);
        });
        applyAllFilters();

        // 10) Panel y popup de filtros
        buildFilterPanelGlobal();
        document.getElementById("filter-panel")
          .classList.toggle("open", filters.filterPanelOpen);
        document.getElementById("popup")
          .classList.toggle("shifted", filters.filterPanelOpen);

        if (circle) {
          showPopup2FromCircle(circle);
        } else {
          window.pendingAnalysisData = loadedData;
        }

        // 11) Restaurar Custom Pins
        localStorage.setItem("customPins", JSON.stringify(customPins));
        loadLocalPins();

        // 12) Restaurar Custom Polygons (con área)
        if (customPolygons) {
          localStorage.setItem("customPolygons", JSON.stringify(customPolygons));
          drawnPolygons.forEach(p => p.setMap(null));
          drawnPolygons = [];
          loadPolygonsFromLocalStorage();
        }

        // 13) Restaurar imported KMZ (ahora incluyendo area)
        if (loadedData.importedKMZ) {
          // a) Guardar raw import para recargas
          localStorage.setItem(
            "importedKMZ",
            JSON.stringify(loadedData.importedKMZ)
          );

          // b) Limpiar viejos
          window.importedKMZPolygons?.forEach(p => p.setMap(null));
          window.importedKMZMarkers?.forEach(m => m.setMap(null));
          window.importedKMZPolygons = [];
          window.importedKMZMarkers = [];

          // c) Polígonos importados con área en customData
          loadedData.importedKMZ.polygons.forEach(polyData => {
            const polygon = new google.maps.Polygon({
              paths:         polyData.paths,
              strokeColor:   polyData.strokeColor || "#000000",
              strokeOpacity: polyData.strokeOpacity || 1.0,
              strokeWeight:  polyData.strokeWeight || 2,
              fillColor:     polyData.fillColor || "#000000",
              fillOpacity:   polyData.fillOpacity || 0.5,
              map,
              clickable:     true,
              zIndex:        98
            });

            // Propagar el área desde el archivo
            polygon.customData = {
              name: polyData.name || "",
              area: polyData.area != null ? polyData.area : google.maps.geometry.spherical.computeArea(polygon.getPath()).toFixed(2)
            };

            applyPolygonTooltip(
              polygon,
              polygon.customData.name,
              p => {
                // si customData.area existe, úsalo; si no, recalcula
                const a = polygon.customData.area;
                return `${Number(a).toLocaleString(undefined, {
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2
                })} m²`;
              }
            );

            polygon.addListener("click", () => {
              if (!confirm(`Delete Polygon "${polygon.customData.name}"?`)) return;
              polygon.setMap(null);
              window.importedKMZPolygons = window.importedKMZPolygons.filter(x => x !== polygon);
              // Actualizar storage con area incluido
              const stored = (() => {
                try {
                  return JSON.parse(localStorage.getItem("importedKMZ") || '{"pins":[],"polygons":[]}');
                } catch (_) {
                  return { pins: [], polygons: [] };
                }
              })();
              stored.polygons = window.importedKMZPolygons.map(p => ({
                name: p.customData.name,
                paths: p.getPath().getArray().map(ll => ({ lat: ll.lat(), lng: ll.lng() })),
                strokeColor: p.strokeColor,
                strokeOpacity: p.strokeOpacity,
                strokeWeight: p.strokeWeight,
                fillColor: p.fillColor,
                fillOpacity: p.fillOpacity,
                area: p.customData.area
              }));
              localStorage.setItem("importedKMZ", JSON.stringify(stored));
            });

            window.importedKMZPolygons.push(polygon);
          });

          // d) Pines importados
          loadedData.importedKMZ.pins.forEach(pinData => {
            const marker = new google.maps.Marker({
              position: pinData.position,
              title:    pinData.name || "",
              map,
              icon:     pinData.iconUrl
                ? {
                    url:       pinData.iconUrl,
                    scaledSize:new google.maps.Size(30, 30)
                  }
                : undefined
            });
            marker.addListener("click", () => {
              if (!confirm(`Delete Marker "${pinData.name}"?`)) return;
              marker.setMap(null);
              window.importedKMZMarkers = window.importedKMZMarkers.filter(m => m !== marker);
              // Actualizar storage de pins
              const stored = (() => {
                try {
                  return JSON.parse(localStorage.getItem("importedKMZ") || '{"pins":[],"polygons":[]}');
                } catch (_) {
                  return { pins: [], polygons: [] };
                }
              })();
              stored.pins = window.importedKMZMarkers.map(mk => ({
                name:    mk.getTitle(),
                position:{ lat: mk.getPosition().lat(), lng: mk.getPosition().lng() },
                iconUrl: mk.getIcon() && (typeof mk.getIcon() === 'string' ? mk.getIcon() : mk.getIcon().url)
              }));
              localStorage.setItem("importedKMZ", JSON.stringify(stored));
            });
            window.importedKMZMarkers.push(marker);
          });
        }

        // 14) Feedback final
        showToast("Analysis imported and restored successfully.");
        document.getElementById("import-files-panel").style.display = "none";
      } catch (e) {
        console.error("Error rebuilding analysis:", e);
      }
    });
  };
  input.click();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

function exportCurrentAnalysis() {
  // 0) Leer y serializar customPins y customPolygons del almacenamiento local
  const customPins = JSON.parse(
    localStorage.getItem("customPins") || "[]"
  );
  const customPolygons = JSON.parse(
    localStorage.getItem("customPolygons") || "[]"
  );

  // 1) Serializamos los polígonos importados para que siempre tengan el formato { paths: [ {lat,lng}, … ] }
  const storedKMZ = JSON.parse(
    localStorage.getItem("importedKMZ") || '{"pins":[],"polygons":[]}'
  );
  const serializedPolygons = (window.importedKMZPolygons || []).map(polygon => ({
    name:         polygon.customData?.name        || "",
    paths:        polygon.getPath().getArray().map(ll => ({ lat: ll.lat(), lng: ll.lng() })),
    strokeColor:  polygon.strokeColor             || "#000000",
    strokeOpacity:polygon.strokeOpacity           || 1.0,
    strokeWeight: polygon.strokeWeight            || 2,
    fillColor:    polygon.fillColor               || "#000000",
    fillOpacity:  polygon.fillOpacity             || 0.5
  }));
  const serializedKMZ = {
    pins:     storedKMZ.pins,
    polygons: serializedPolygons
  };

  // 2) Construimos el resto de datos del análisis
  const pins = markers
    .filter(m => m.getVisible() && m.__visibleByFranchise)
    .map(m => ({
      franchise:  m.franchise,
      address:    m.Address,
      category:   m.category,
      subcategory:m.subcategory,
      operations: m.Operations,
      location:   m.location
    }));

  const rulerLine = rulerPolyline && rulerPolyline.getPath().getLength() === 2
    ? {
        pointA: {
          lat: rulerPolyline.getPath().getAt(0).lat(),
          lng: rulerPolyline.getPath().getAt(0).lng()
        },
        pointB: {
          lat: rulerPolyline.getPath().getAt(1).lat(),
          lng: rulerPolyline.getPath().getAt(1).lng()
        }
      }
    : null;

  // 3) Estado del panel de filtros abierto (opcional)
  const filterPanelOpen = document.getElementById("filter-panel")
    ?.classList.contains("open") || false;

  // 4) Construir el objeto data a exportar
  const data = {
    date:           new Date().toISOString(),
    center:         map.getCenter().toJSON(),
    zoom:           map.getZoom(),
    circle:         currentCircle
                      ? {
                          center: currentCircle.getCenter().toJSON(),
                          radius: currentCircle.getRadius()
                        }
                      : null,
    popupData:      popup2Data || null,
    rulerLine:      rulerLine,
    visibleMarkers: pins,
    importedKMZ:    serializedKMZ,     // polígonos y pines importados
    customPins:     customPins,        // pines creados manualmente
    customPolygons: customPolygons,    // polígonos creados manualmente
    activeFilters:  {
      locations:   Array.from(activeLocations),
      categories:  Array.from(activeCategories),
      subcategories:Array.from(activeSubcategories),
      operations:  Array.from(activeOperations),
      franchises:  Array.from(activeFranchises),
      statuses:    Array.from(activeStatuses),
      levels:      Array.from(activeLevels)
    },
    filterPanelOpen: filterPanelOpen  // para restaurar estado del panel
  };

  // -------------------------------------------------------------------------
  // Incluir la selección de estados y municipios en la exportación JSON
  try {
    const { selectedStates, selectedMunicipios } = gatherSelectedMunicipios();
    if (selectedStates && selectedStates.length > 0) {
      data.selectedStates = selectedStates;
    }
    if (selectedMunicipios && selectedMunicipios.length > 0) {
      data.selectedMunicipios = selectedMunicipios;
    }
  } catch (err) {
    console.warn('No se pudieron capturar los estados/municipios seleccionados (exportCurrentAnalysis):', err);
  }

  // 5) Generar y descargar el JSON
  const blob = new Blob(
    [JSON.stringify(data, null, 2)],
    { type: "application/json" }
  );
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = (
    document.getElementById("filename-input")?.value || "analysis"
  ) + ".json";
  a.click();
  URL.revokeObjectURL(url);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
// Funciones auxiliares para la selección de estados y municipios

/**
 * Recorre el listado de estados/municipios en el panel de City Limits y
 * devuelve los estados y municipios actualmente seleccionados por el usuario.
 * Si el panel no está presente, devuelve listas vacías.
 * @returns {{selectedStates: string[], selectedMunicipios: Array<{state: string, muni: string}>}}
 */
function gatherSelectedMunicipios() {
  const result = { selectedStates: [], selectedMunicipios: [] };
  const lista = document.getElementById('municipios-list');
  if (!lista) return result;
  // Cada estado está representado por un div con class state-group
  lista.querySelectorAll('.state-group').forEach(group => {
    const header = group.querySelector('.state-header');
    if (!header) return;
    // El label del estado es el último span dentro del header
    const stateLabelSpan = header.querySelector('span:last-child');
    const stateName = stateLabelSpan ? stateLabelSpan.textContent.trim() : '';
    const stateCb = header.querySelector('input[type="checkbox"]');
    if (stateCb && stateCb.checked && stateName) {
      result.selectedStates.push(stateName);
    }
    // Ahora recorre los hijos (checkbox de municipios)
    const muniCbs = group.querySelectorAll('div > label input[type="checkbox"]');
    muniCbs.forEach(cb => {
      if (cb.checked) {
        const state = cb.dataset.state;
        const muni  = cb.dataset.muni;
        if (state && muni) {
          result.selectedMunicipios.push({ state, muni });
        }
      }
    });
  });
  return result;
}

/**
 * Restaura la selección de municipios utilizando la lista proporcionada. Este
 * método intenta marcar los checkboxes de municipios que coinciden con los
 * nombres proporcionados y dispara el evento "change" para que los
 * polígonos asociados se muestren en el mapa. Si algún checkbox no existe
 * aún (por ejemplo, si el panel aún no se ha construido), la función no
 * tendrá efecto sobre ese municipio. Puede llamarse varias veces sin efectos
 * adversos.
 * @param {Array<{state:string, muni:string}>} selectedMunicipios 
 */
function restoreSelectedMunicipios(selectedMunicipios) {
  if (!Array.isArray(selectedMunicipios) || selectedMunicipios.length === 0) return;
  selectedMunicipios.forEach(sel => {
    try {
      const selector = `#municipios-list input[data-state="${sel.state}"][data-muni="${sel.muni}"]`;
      const cb = document.querySelector(selector);
      if (cb && !cb.checked) {
        cb.checked = true;
        // Dispara el evento change para activar el polígono
        cb.dispatchEvent(new Event('change'));
      }
    } catch (_) {
      // ignora si no puede marcar
    }
  });
}

(function() {
    const toggleBtn   = document.getElementById('notes-toggle');
    const panel       = document.getElementById('notes-panel');
    const saveBtn     = document.getElementById('save-note');
    const clearBtn    = document.getElementById('clear-notes');
    const input       = document.getElementById('note-input');
    const list        = document.getElementById('notes-list');
    const STORAGE_KEY = 'notePad';
    let notes = [];

    // Cargar notas al iniciar
    function loadNotes() {
      notes = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
      renderNotes();
    }

    // Renderizar la lista de notas
    function renderNotes() {
      list.innerHTML = '';
      notes.forEach((text, i) => {
        const item = document.createElement('div');
        item.className = 'note-item';
        item.textContent = text;
        // botón para borrar nota individual
        const del = document.createElement('button');
        del.innerHTML = '✖️';
        del.title = 'Borrar nota';
        del.addEventListener('click', () => {
          notes.splice(i, 1);
          saveToStorage();
          renderNotes();
        });
        item.appendChild(del);
        list.appendChild(item);
      });
    }

    // Guardar array en localStorage
    function saveToStorage() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(notes));
    }

    // Handlers
    toggleBtn.addEventListener('click', () => {
      panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
    });

    saveBtn.addEventListener('click', () => {
      const text = input.value.trim();
      if (!text) return alert('Escribe algo antes de guardar.');
      notes.push(text);
      saveToStorage();
      renderNotes();
      input.value = '';
      input.focus();
    });

    clearBtn.addEventListener('click', () => {
      if (!notes.length || !confirm('¿Borrar todas las notas?')) return;
      notes = [];
      localStorage.removeItem(STORAGE_KEY);
      renderNotes();
    });

    // Inicializar
    loadNotes();
  })();




document.getElementById("drawPolygonBtn").addEventListener("click", () => {
    if (!drawingManager) initPolygonDrawing();
    const currentMode = drawingManager.getDrawingMode();
    playSound("sounds/draw.mp3");
  
    drawingManager.setDrawingMode(currentMode ? null : google.maps.drawing.OverlayType.POLYGON);
  });
  
  function initPolygonDrawing() {
    drawingManager = new google.maps.drawing.DrawingManager({
      drawingMode: null,
      drawingControl: false,
      polygonOptions: {
        editable:   false,
        draggable:  false,
        clickable:  true,
        strokeColor: isDarkMode ? "#FFFFFF" : "#FF6600",
        fillColor:   isDarkMode ? "#FF6600" : "#000000",
        fillOpacity: 0.35,
        zIndex:      1
      }
    });
    drawingManager.setMap(map);
  
    // — ÚNICAMENTE un listener aquí —
    google.maps.event.addListener(drawingManager, 'overlaycomplete', event => {
      if (event.type !== google.maps.drawing.OverlayType.POLYGON) return;
      const polygon = event.overlay;
  
      // 1) Pedir nombre
      const name = prompt("Polygon Name?");
      if (!name) {
        polygon.setMap(null);
        return;
      }
  
      // 2) Extraer coordenadas
      const path = polygon.getPath().getArray().map(c => ({
        lat: c.lat(),
        lng: c.lng()
      }));
  
      // 3) Calcular área (m²)
      const rawArea = google.maps.geometry.spherical.computeArea(polygon.getPath());
      const area    = parseFloat(rawArea.toFixed(2));
  
      // 4) Guardar en el array (incluyendo el área)
      customPolygons.push({
        name,
        paths: path,
        area      // ← aquí
      });
      savePolygonsToLocalStorage();
  
      // 5) Mostrar tooltip con área
      polygon.addListener("mouseover", () => {
        const formatted = new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        }).format(area);
        tooltipDiv.innerHTML = `<strong>${name}</strong><br>${formatted} m²`;
        tooltipDiv.style.display = "block";
      });
      polygon.addListener("mousemove", e => {
        const pos = tooltipOverlay.getProjection()
                      .fromLatLngToDivPixel(e.latLng);
        tooltipDiv.style.left = pos.x + "px";
        tooltipDiv.style.top  = pos.y + "px";
      });
      polygon.addListener("mouseout", () => {
        tooltipDiv.style.display = "none";
      });
  
      // 6) Resto de lógica (detener dibujo, sonido, borrado…)
      drawingManager.setDrawingMode(null);
      playSound("sounds/polygon.mp3");
      drawnPolygons.push(polygon);
  
      polygon.addListener("click", () => {
        tooltipDiv.style.display = "none";
        if (!confirm(`Delete Polygon "${name}"?`)) return;
        polygon.setMap(null);
        playSound("sounds/trash.mp3");
        drawnPolygons = drawnPolygons.filter(p => p !== polygon);
        customPolygons  = customPolygons.filter(p => p.name !== name);
        removePolygonFromLocalStorage(name);
      });
    });
  }
  
  
  
  
    // customPolygons ahora incluye { name, paths, area }
    function savePolygonsToLocalStorage() {
      const data = customPolygons.map(item => ({
        name:        item.name,
        paths:       item.paths,
        area:        item.area,                         // ← asegurado
        strokeColor: isDarkMode ? "#FFFFFF" : "#FF6600",
        fillColor:   isDarkMode ? "#FF6600" : "#000000",
        fillOpacity: 0.35,
        clickable:   true,
        zIndex:      1
      }));
      localStorage.setItem("customPolygons", JSON.stringify(data));
    }    
  
  

  function removePolygonFromLocalStorage(nameToRemove) {
    const stored = JSON.parse(localStorage.getItem("customPolygons")) || [];
    const updated = stored.filter(p => p.name !== nameToRemove);
    localStorage.setItem("customPolygons", JSON.stringify(updated));
    // actualiza también el array en memoria
    customPolygons = customPolygons.filter(p => p.name !== nameToRemove);
  }
  
  
  function loadPolygonsFromLocalStorage() {
    // 1) Limpia lo anterior
    drawnPolygons.forEach(poly => poly.setMap(null));
    drawnPolygons = [];
    customPolygons = [];
  
    // 2) Recupera y parsea
    const raw = localStorage.getItem("customPolygons");
    if (!raw) return;
    const data = JSON.parse(raw);
  
    data.forEach(item => {
      const { name, paths, area } = item;
      if (!Array.isArray(paths) || paths.length < 3) return;
  
      // 3) Crea el polígono
const pathLatLng = paths.map(coord => new google.maps.LatLng(coord.lat, coord.lng));

const polygon = new google.maps.Polygon({
  paths: pathLatLng,
  strokeColor: isDarkMode ? "#FFFFFF" : "#FF6600",
  fillColor:   isDarkMode ? "#FF6600" : "#000000",
  fillOpacity: item.fillOpacity ?? 0.35,
  map,
  clickable:   true
});
  
      // 4) Guarda el área en customData para usarla luego
      polygon.customData = { name, area };
  
      // 5) Pasa el área guardada al tooltip
      applyPolygonTooltip(polygon, name, () => {
        return `${Number(area).toLocaleString(undefined,{
          minimumFractionDigits:2,
          maximumFractionDigits:2
        })} m²`;
      });
  
      // 6) Guarda referencias
      drawnPolygons.push(polygon);
      customPolygons.push({ name, paths, area });
      
      polygon.addListener("click", () => {
        if (!confirm(`Delete Polygon "${name}"?`)) return;
        polygon.setMap(null);
        removePolygonFromLocalStorage(name);
      });
    });
  
    // 7) Reajusta bounds si quieres
    const bounds = new google.maps.LatLngBounds();
    drawnPolygons.forEach(poly =>
      poly.getPath().getArray().forEach(pt => bounds.extend(pt))
    );
    if (!bounds.isEmpty()) map.fitBounds(bounds);
  }
  

  function applyPolygonTooltip(polygon, name) {
    polygon.__name = name;
    polygon.addListener('mouseover', e => {
      const area = google.maps.geometry.spherical.computeArea(polygon.getPath());
      const formatted = new Intl.NumberFormat('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(area);
      tooltipDiv.innerHTML = `<strong>${name}</strong><br>${formatted} m²`;
      tooltipDiv.style.display = 'block';
    });
    polygon.addListener('mousemove', e => {
      const pos = tooltipOverlay.getProjection().fromLatLngToDivPixel(e.latLng);
      tooltipDiv.style.left = pos.x + 'px';
      tooltipDiv.style.top  = pos.y + 'px';
    });
    polygon.addListener('mouseout', () => {
      tooltipDiv.style.display = 'none';
    });
  }

  function getPolygonCenter(polygon) {
    const bounds = new google.maps.LatLngBounds();
    polygon.getPath().forEach(function (path) {
      bounds.extend(path);
    });
    return bounds.getCenter();
  }


  document.getElementById('portfolio-options').addEventListener('click', () => {
  const panel = document.getElementById('portfolio-options-panel');
  
  // Alternar clase y visibilidad
  const isOpen = panel.classList.contains('open');
  if (isOpen) {
    panel.classList.remove('open');
    panel.style.display = 'none';
  } else {
    panel.classList.add('open');
    panel.style.display = 'block';
  }
});



let portfolioSheetURL = "";

document.getElementById('load-portfolio').addEventListener('click', () => {
  const inputURL = prompt("Paste here the Google Sheet URL(public CSV format only):");

  if (!inputURL || !inputURL.includes("docs.google.com")) {
    alert("❌ Ingresa una URL válida de Google Sheets.");
    return;
  }

  let csvURL = inputURL.trim();

  if (csvURL.includes("/edit")) {
    const match = csvURL.match(/\/d\/([a-zA-Z0-9-_]+)/);
    if (!match) {
      alert("❌ No se pudo extraer el ID del Google Sheet.");
      return;
    }
    const sheetId = match[1];
    csvURL = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv`;
  }

  // Guardar la URL en localStorage
  localStorage.setItem("portfolioSheetURL", csvURL);
  portfolioSheetURL = csvURL;

  fetch(csvURL)
    .then(res => {
      if (!res.ok) throw new Error("Error al descargar el archivo");
      return res.text();
    })
    .then(csvText => {
      const rows = Papa.parse(csvText, { header: true }).data;

      const properties = rows
        .map(row => {
          const lat = parseFloat(row.lat || row.Latitude);
          const lng = parseFloat(row.lng || row.Longitude);
          if (isNaN(lat) || isNaN(lng)) return null;

          return {
            name: row.property || "Propiedad sin nombre",
            location: row.location || "",
            category: row.category || "",
            building: row.building || "",
            land: row.land || "",
            ticket: row.ticket || "",
            status: row.status || "",
            tenant: row.tenant || "",
            rent: row.rent || "",
            cap: row.cap || "",

            portfolio: row.portfolio || "",
            lat, lng
          };
        })
        .filter(p => p);

      renderPortfolioPins(properties);
      alert(`✅ Loaded ${properties.length} properties in the Portfolio`);
    })
    .catch(err => {
      console.error(err);
      alert("❌ Hubo un problema al cargar el archivo.");
    });
});

function renderPortfolioPins(properties) {
  properties.forEach(p => {
    const marker = new google.maps.Marker({
      position: { lat: p.lat, lng: p.lng },
      map,
      title: p.name,
      icon: {
        url: "https://static.wixstatic.com/media/805cf6_5664629e1dc04ddf8bd9c500f9552ef6~mv2.png",
        scaledSize: new google.maps.Size(30, 34)
      }
    });

    const tooltipHTML = `
      <strong>${p.name}</strong><br>
      Ubicación: ${p.location}<br>
      Área: ${p.area}<br>
      Precio: ${p.ticket}<br>
      Portafolio: ${p.portfolio}
    `;

    marker.addListener("mouseover", () => {
      infoWindow.setContent(tooltipHTML);
      infoWindow.open(map, marker);
    });

    marker.addListener("mouseout", () => {
      infoWindow.close();
    });

  });
}



function loadPortfolioFromStorage() {
  const savedURL = localStorage.getItem("portfolioSheetURL");
  if (!savedURL) return;

  fetch(savedURL)
    .then(res => res.text())
    .then(csvText => {
      const rows = Papa.parse(csvText, { header: true }).data;

      const properties = rows
        .map(row => {
          const lat = parseFloat(row.lat || row.Latitude);
          const lng = parseFloat(row.lng || row.Longitude);
          if (isNaN(lat) || isNaN(lng)) return null;

          return {
            name: row.property || "Propiedad sin nombre",
            location: row.location || "",
            category: row.category || "",
            building: row.building || "",
            land: row.land || "",
            ticket: row.ticket || "",
            status: row.status || "",
            tenant: row.tenant || "",
            rent: row.rent || "",
            cap: row.cap || "",

            portfolio: row.portfolio || "",
            lat, lng
          };
        })
        .filter(p => p);

      renderPortfolioPins(properties);

      // ✅ Esperar a que desaparezca el #start-screen para mostrar mensaje
      const waitUntilStartScreenGone = setInterval(() => {
        const screen = document.getElementById('start-screen');
        if (!screen || screen.style.display === 'none') {
          clearInterval(waitUntilStartScreenGone);
          alert(`✅ Loaded ${properties.length} properties from the Portolio URL.`);
        }
      }, 300);
    })
    .catch(err => {
      console.error("Error cargando el portafolio inicial:", err);
    });
}


google.charts.load("current", { packages: ["corechart"] });

document.getElementById("portfolio-snapshot").addEventListener("click", async () => {
  const savedURL = localStorage.getItem("portfolioSheetURL");
  if (!savedURL) {
    alert("Error: Portfolio not found, add a Google Sheet URL again.");
    return;
  }

  try {
    const res = await fetch(savedURL);
    const text = await res.text();
    const rows = Papa.parse(text, { header: true }).data;

    const groupedByCategory = {};
    let totalTicket = 0;
    let count = 0;

    const cleanedRows = [];

    rows.forEach(row => {
      const ticketRaw = row.ticket ?? row.Ticket ?? "";
      const ticket = parseFloat(ticketRaw.toString().replace(/[^0-9.]/g, ""));
      const category = row.category?.trim() || "Sin categoría";

      if (!isNaN(ticket)) {
        totalTicket += ticket;
        count++;
        if (!groupedByCategory[category]) groupedByCategory[category] = 0;
        groupedByCategory[category] += ticket;

        cleanedRows.push({
          name: row.property || "Sin nombre",
          category,
          ticket
        });
      }
    });

// 1) Prepara los datos
const categories = Object.keys(groupedByCategory);
const totals     = categories.map(cat => groupedByCategory[cat]);
const maxValue   = Math.max(...totals);
const minValue   = Math.min(...totals);

// 2) Define colores de inicio y fin en RGB
const startRGB = [255, 102, 0];    // #ff6600
const endRGB = [107, 107, 107]; // #FFCC99

// 3) Calcula un mapa categoría→color
const categoryColors = {};
categories.forEach(cat => {
  const value = groupedByCategory[cat];
  // ratio: 0 cuando value===max → startRGB; 1 cuando value===min → endRGB
  const t = (maxValue === minValue)
    ? 0
    : (maxValue - value) / (maxValue - minValue);

  // interpolación RGB
  const r = Math.round(startRGB[0] + t * (endRGB[0] - startRGB[0]));
  const g = Math.round(startRGB[1] + t * (endRGB[1] - startRGB[1]));
  const b = Math.round(startRGB[2] + t * (endRGB[2] - startRGB[2]));

  // convierte a hex "#rrggbb"
  categoryColors[cat] =
    "#" + ((1 << 24) | (r << 16) | (g << 8) | b)
      .toString(16)
      .slice(1);
});

// 4) Llena el DataTable y construye el array de colores
const pieData = new google.visualization.DataTable();
pieData.addColumn("string", "Categoría");
pieData.addColumn("number", "Total Ticket");

categories.forEach(cat => {
  pieData.addRow([cat, groupedByCategory[cat]]);
});

const colors = categories.map(cat => categoryColors[cat]);

// 5) Dibuja el gráfico incluyéndolas
const pieChart = new google.visualization.PieChart(
  document.getElementById("portfolio-popup-chart")
);

pieChart.draw(pieData, {
  pieHole: 0.4,
  chartArea: { width: "100%", height: "100%", top: 40 },
  legend: "none",
  pieSliceText: "percentage",
  pieSliceTextStyle: {
    color: "white",
    fontSize: 12,
    bold: true
  },
  tooltip: { text: "both" },

  // <-- aquí van tus colores degradados -->
  colors: colors
});

    // RESUMEN
    const summaryDiv = document.getElementById("portfolio-summary");
    const formattedTotal = new Intl.NumberFormat("en-US").format(totalTicket);
    summaryDiv.innerHTML = `
      <div style="margin-bottom: 5px;">
        <strong>Portfolio Value:</strong> $${formattedTotal}
      </div>
      <div>
        <strong>${count}</strong> ${count === 1 ? 'property' : 'properties'}
      </div>
    `;

    // SELECT DE CATEGORÍA
    const select = document.getElementById("category-filter");
    const uniqueCategories = [...new Set(cleanedRows.map(r => r.category).filter(Boolean))].sort();
    select.innerHTML = '<option value="">Todas</option>';
    uniqueCategories.forEach(cat => {
      const option = document.createElement("option");
      option.value = cat;
      option.textContent = cat;
      select.appendChild(option);
    });

    // DIBUJAR BARRAS
    drawBarChart(cleanedRows, ""); // muestra todas por default

    // Mostrar popup
    document.getElementById("portfolio-popup").style.display = "block";

  } catch (err) {
    console.error("❌ Error al generar gráfica del portafolio:", err);
    alert("Hubo un error al procesar la gráfica.");
  }
});


function drawBarChart(data, filterCategory = "") {
  const filtered = filterCategory
    ? data.filter(r => r.category === filterCategory)
    : data;

  const top10 = filtered
    .sort((a, b) => b.ticket - a.ticket)
    .slice(0, 5);

  const chartData = new google.visualization.DataTable();
  chartData.addColumn("string", "Propiedad");
  chartData.addColumn("number", "Ticket");

  top10.forEach(item => {
    chartData.addRow([item.name, item.ticket]);
  });

  const chart = new google.visualization.ColumnChart(
    document.getElementById("portfolio-bar-chart")
  );

  chart.draw(chartData, {
    chartArea: { width: "90%", height: "80%" },
    hAxis: { textStyle: { fontSize: 11 } },
    vAxis: { title: "Ticket", format: "short" },
    colors: ["#ff6600"],
    legend: "none"
  });
}

function updateBarChartByCategory() {
  const selected = document.getElementById("category-filter").value;
  // Reutiliza los datos ya limpiados de la función anterior
  const savedURL = localStorage.getItem("portfolioSheetURL");
  if (!savedURL) return;

  fetch(savedURL)
    .then(res => res.text())
    .then(text => {
      const rows = Papa.parse(text, { header: true }).data;
      const cleaned = rows
        .map(r => {
          const t = parseFloat((r.ticket ?? "").toString().replace(/[^0-9.]/g, ""));
          return {
            name: r.property || "Sin nombre",
            category: r.category?.trim() || "Sin categoría",
            ticket: isNaN(t) ? 0 : t
          };
        })
        .filter(r => r.ticket > 0);

      drawBarChart(cleaned, selected);
    });
}

function closePortfolioPopup() {
  document.getElementById("portfolio-popup").style.display = "none";
}

function saveResearchPin() {
  if (!selectedResearchCoords) {
    alert("No se ha seleccionado una ubicación.");
    return;
  }

  const franchise = document.getElementById("research-franchise").value.trim();
  const operations = document.getElementById("research-operations").value.trim();
  const address    = document.getElementById("research-address").value.trim();
  const location   = document.getElementById("research-location").value.trim();

  if (!franchise || !operations || !address || !location) {
    alert("Por favor llena todos los campos.");
    return;
  }

  // 🔹 Aseguramos tipo número
  const latitude  = Number(selectedResearchCoords.lat());
  const longitude = Number(selectedResearchCoords.lng());

const pinData = {
  Franchise: franchise,
  Operations: operations,
  Address: address,
  Location: location,
  Latitude: latitude,
  Longitude: longitude
};

  const arr = JSON.parse(localStorage.getItem("researchPins") || "[]");
  arr.push(pinData);
  localStorage.setItem("researchPins", JSON.stringify(arr));

  // feedback
  playSound("sounds/bubble.mp3");

  // marcador
  const marker = new google.maps.Marker({
    position: { lat: latitude, lng: longitude },
    map,
    animation: google.maps.Animation.DROP,
    draggable: true,
    icon: {
      url: "https://static.wixstatic.com/media/805cf6_c60c413bdd6545f78929a4d92196dcd5~mv2.png",
      scaledSize: new google.maps.Size(38, 38)
    },
    title: franchise
  });
  marker._pinId = pinData.id;

  // eliminar (lee storage fresco)
  marker.addListener("click", () => {
    if (!confirm(`¿Deseas eliminar "${franchise}"?`)) return;
    marker.setMap(null);
    playSound("sounds/trash.mp3");
    const fresh = JSON.parse(localStorage.getItem("researchPins") || "[]");
    const updated = fresh.filter(p => p.id !== marker._pinId);
    localStorage.setItem("researchPins", JSON.stringify(updated));
  });

  // reset UI
  closeResearchPinForm();
  researchPinMode = false;
  selectedResearchCoords = null;
  map.setOptions({ draggableCursor: null });

  // depuración rápida
  console.table([pinData]);
}





function loadResearchPins() {
  // 1) Recupera tu array de pines con Franchise, Operations, Address, Location, Latitude, Longitude
  const stored = JSON.parse(localStorage.getItem("researchPins") || "[]");

  stored.forEach(pin => {
    // 2) Convierte latitud y longitud a número
    const lat = parseFloat(pin.Latitude);
    const lng = parseFloat(pin.Longitude);

    // 3) Verifica que sean válidos
    if (Number.isFinite(lat) && Number.isFinite(lng)) {
      // 4) Crea el marcador
      const marker = new google.maps.Marker({
        position: { lat, lng },
        map: map,
        animation: google.maps.Animation.DROP,
        icon: {
          url: "https://static.wixstatic.com/media/805cf6_c60c413bdd6545f78929a4d92196dcd5~mv2.png",
          scaledSize: new google.maps.Size(38, 38),
        },
        draggable: true,
        title: pin.Franchise || "Research Pin"
      });

      // 5) Al hacer clic, pregunta y elimina tanto del mapa como del localStorage
      marker.addListener("click", () => {
        const confirmDelete = confirm(`¿Deseas eliminar "${pin.Franchise}"?`);
        if (!confirmDelete) return;

        // quita del mapa
        marker.setMap(null);
        playSound("sounds/trash.mp3");

        // filtra el array, removiendo sólo el pin con estas coordenadas exactas
        const updated = stored.filter(p =>
          !(parseFloat(p.Latitude) === lat && parseFloat(p.Longitude) === lng)
        );
        localStorage.setItem("researchPins", JSON.stringify(updated));
      });
    }
  });
}





// === Configuración inicial ===
const tomtomApiKey = "KRfT1i0GTTicpvhrNY7Xi2nRQMlIGR24";

document.addEventListener("DOMContentLoaded", () => {
  // Calendario para la fecha
  flatpickr("#traffic-date", {
    dateFormat: "Y-m-d",
    maxDate: "today",
    defaultDate: "today"
  });

  // Autocompletado TomTom
  initTomTomAutocomplete("start-location");

  // Toggle del panel UI (opcional)
  document
    .getElementById("traffic-ui-toggle")
    .addEventListener("click", () => {
      const ui = document.getElementById("traffic-analysis-ui");
      ui.style.display = ui.style.display === "none" ? "block" : "none";
    });
});

// === Autocompletado TomTom ===
function initTomTomAutocomplete(inputFieldId) {
  const inputEl = document.getElementById(inputFieldId);
  const tomtomSearchBox = new tt.plugins.SearchBox(tt.services, {
    searchOptions: {
      key: tomtomApiKey,
      language: "es-MX",
      limit: 5
    }
  });
  tomtomSearchBox.attachTo(inputEl);
}

// === Función para asignar color según P50 ===
function getSpeedColor(p50) {
  if (p50 == null) return "#888888";
  if (p50 < 20)    return "#d73027";
  if (p50 < 40)    return "#fee08b";
  return "#1a9850";
}

// === Mostrar/Ocultar tramos reales de tráfico ===
let trafficPolylineList = [];
let trafficIsVisible = false;

function drawTrafficVolumeBySegment() {
  if (trafficIsVisible) {
    // Toggle off
    trafficPolylineList.forEach(poly => poly.setMap(null));
    trafficPolylineList = [];
    trafficIsVisible = false;
    return;
  }

  // 1) Cargar índice de GeoJSON
  fetch("files/tomtom/index.json")
    .then(res => {
      if (!res.ok) throw new Error("HTTP " + res.status);
      return res.json();
    })
    // 2) Descargar en paralelo cada archivo listado
    .then(fileNames => {
      return Promise.all(
        fileNames.map(name =>
          fetch(`files/tomtom/${name}`)
            .then(res => {
              if (!res.ok) throw new Error("HTTP " + res.status);
              return res.json();
            })
        )
      );
    })
    // 3) Dibujar cada GeoJSON
    .then(geojsonArray => {
      geojsonArray.forEach(geojson => {
        console.log("GeoJSON cargado:", geojson.features.length, "features");

        geojson.features.forEach(feature => {
          if (!feature.geometry?.coordinates) return;

          const props  = feature.properties;
          const coords = feature.geometry.coordinates.map(c => ({ lat: c[1], lng: c[0] }));

          // Extraer P50 de ejemplo ("6:00-9:00")
          let p50 = null;
          if (props.timeSets?.["6:00-9:00"]) {
            p50 = props.timeSets["6:00-9:00"].speedPercentiles[9];
          }
          const color = getSpeedColor(p50);

          // Dibujar polyline
          const polyline = new google.maps.Polyline({
            path: coords,
            strokeColor: color,
            strokeOpacity: 0.9,
            strokeWeight: 4,
            map: map
          });

          // InfoWindow con chart y tooltip personalizado
          polyline.addListener("click", () => {
            const timeSets     = props.timeSets || {};
            const totalVehicles = Object.values(timeSets)
              .reduce((sum, d) => sum + (d.sampleSize || 0), 0);

            // IDs únicos para el contenedor del chart
            const segmentId   = props.segmentId || props.streetName.replace(/\W/g, '');
            const containerId = `traffic-chart-${segmentId}`;

            const formattedTotal = totalVehicles.toLocaleString('en-US');
            const html = `
              <div style="
                  font-family:Arial,sans-serif;
                  font-size:12px;
                  width:325px;
                  text-align:center;
                ">
                <strong style="display:block; font-size:14px; margin-bottom:4px;">
                  ${props.streetName}
                </strong>
                <div style="margin-bottom:12px; font-size:12px; color:#555;">
                  Total Monthly Vehicles: ${formattedTotal}
                </div>
                <div
                  id="${containerId}"
                  style="
                    width:100%;
                    height:225px;
                    margin:0 auto;
                  "
                ></div>
              </div>`;

            const infoWindow = new google.maps.InfoWindow({
              content: html,
              position: coords[0]
            });
            infoWindow.open(map);

            google.maps.event.addListenerOnce(infoWindow, 'domready', () => {
              // 1) Preparar datos para Google Charts
              const dataArray = [
                ['Horario', 'Cantidad', { role: 'annotation' }, { role: 'tooltip' }]
              ];
              Object.entries(timeSets).forEach(([ts, d]) => {
                const count = d.sampleSize || 0;
                const miles = count / 1000;
                const pct   = totalVehicles
                  ? ((count / totalVehicles) * 100).toFixed(1) + '%'
                  : '0%';
                dataArray.push([ts, miles, miles.toFixed(1), pct]);
              });

              // 2) Calcular tope Y
              const valores = dataArray.slice(1).map(r => r[1]);
              let maximo = Math.max(...valores) * 1.25;
              if (maximo <= 0) maximo = 1;

              // 3) Configurar opciones del chart
              const options = {
                colors: ['#FF6600'],
                legend: { position: 'none' },
                annotations: {
                  alwaysOutside: true,
                  textStyle: { fontSize: 10, color: '#000' }
                },
                tooltip: { trigger: 'focus' },
                vAxis: {
                  title: 'Count (thousands)',
                  format: 'decimal',
                  minValue: 0,
                  maxValue: maximo,
                  gridlines: { count: 6 }
                },
                hAxis: {
                  title: 'Day Segments',
                  slantedText: true,
                  slantedTextAngle: 90,
                  textStyle: { fontSize: 9 },
                  showTextEvery: 1,
                  allowContainerBoundaryTextCutoff: false
                },
                chartArea: {
                  left: 35, right: 35, top: 10, bottom: 120,
                  width: '65%', height: '85%'
                }
              };

              // 4) Dibujar chart
              const data  = google.visualization.arrayToDataTable(dataArray);
              const chart = new google.visualization.ColumnChart(
                document.getElementById(containerId)
              );
              chart.draw(data, options);

              // 5) Asegurar que no queden scrollbars
              const iwOuter = document.querySelector('.gm-style-iw');
              if (iwOuter) {
                const panes = iwOuter.querySelectorAll('.gm-style-iw-d');
                panes.forEach(div => {
                  div.style.overflow  = 'visible';
                  div.style.maxHeight = 'none';
                  div.style.maxWidth  = 'none';
                });
              }
            });
          });

          trafficPolylineList.push(polyline);
        });
      });

      // Marcar como visible
      trafficIsVisible = true;
    })
    .catch(err => {
      console.error("Error cargando GeoJSON de tramos reales:", err);
    });
}


const btnLoad   = document.getElementById('btnLoadExcel');
const fileInput = document.getElementById('fileInputExcel');

btnLoad.addEventListener('click', () => fileInput.click());

fileInput.addEventListener('change', event => {
  const file = event.target.files[0];
  if (!file) return;

  document.getElementById("export-files-panel")?.style.setProperty('display', 'none');

  const reader = new FileReader();
  reader.onload = e => {
    const data     = new Uint8Array(e.target.result);
    const workbook = XLSX.read(data, { type: 'array' });

    // nombres de hoja
    const names = workbook.SheetNames;
    const mName         = names.find(n => /marker/i.test(n))    || names[0];
    const pName         = names.find(n => /polygon/i.test(n))   || names[1] || names[0];
    const portfolioName = names.find(n => /portfolio/i.test(n)); // detectar hoja Portfolio

    // leer hojas si existen
    const markerRows    = XLSX.utils.sheet_to_json(workbook.Sheets[mName]     || {});
    const polygonRows   = XLSX.utils.sheet_to_json(workbook.Sheets[pName]     || {});
    const portfolioRows = portfolioName
      ? XLSX.utils.sheet_to_json(workbook.Sheets[portfolioName])
      : [];

    // formatea markers
const formattedMarkers = markerRows.map(row => {
  const nameVal = row.Name || row.name || "";
  const latVal  = parseFloat(row.Latitude || row.latitude || row.lat || row.Lat);
  const lngVal  = parseFloat(row.Longitude || row.longitude || row.lng || row.Lng);
  let iconUrl   = row.icon || "";

  if (iconUrl) {
    try { iconUrl = JSON.parse(iconUrl).url; } catch (e) {}
  }

  if (!iconUrl) {
    iconUrl = "https://static.wixstatic.com/media/805cf6_c60c413bdd6545f78929a4d92196dcd5~mv2.png";
  }

  return {
    name: nameVal,
    position: { lat: latVal, lng: lngVal },
    icon: {
      url: iconUrl,
      scaledSize: { width: 30, height: 30 }
    }
  };
}).filter(m => !isNaN(m.position.lat) && !isNaN(m.position.lng));

    // formatea polígonos desde WKT
    const formattedPolygons = polygonRows.map(row => {
      const wkt = String(row.WKT || row.wkt || "").trim();
      let paths = [];
      if (wkt.toUpperCase().startsWith("POLYGON")) {
        const inner = wkt.slice(wkt.indexOf("((") + 2, wkt.lastIndexOf("))"));
        paths = inner.split(",").map(pair => {
          const [lng, lat] = pair.trim().split(/\s+/).map(Number);
          return { lat, lng };
        });
      }
      return { name: row.name || "", paths };
    }).filter(p => p.paths.length >= 3);

    // guardar markers y polígonos en excelData
    localStorage.setItem('excelData', JSON.stringify({
      markers: formattedMarkers,
      polygons: formattedPolygons
    }));

    // guardar portfolioData si hay hoja Portfolio y renderizar
    if (portfolioRows.length > 0) {
      localStorage.setItem("portfolioData", JSON.stringify(portfolioRows));
      console.log(`[Import] ${portfolioRows.length} propiedades cargadas al portafolio.`);
      renderPortfolioProperties(); // ← dibujar en el mapa
    }

    renderAll(formattedMarkers, formattedPolygons);
  };

  reader.readAsArrayBuffer(file);
});

// Función para renderizar propiedades del portafolio
function renderPortfolioProperties() {
  let portfolio = JSON.parse(localStorage.getItem("portfolioData") || "[]");

  portfolio.forEach((item, index) => {
    const lat = parseFloat(item.latitude || item.lat);
    const lng = parseFloat(item.longitude || item.lng);
    if (isNaN(lat) || isNaN(lng)) return;

    const marker = new google.maps.Marker({
      position: { lat, lng },
      map,
      title: item.name || item.name || "",
      icon: {
        url: "https://static.wixstatic.com/media/805cf6_f88c89ec4f36480281cad7f3f040be4b~mv2.png",
        scaledSize: new google.maps.Size(38, 38)
      }
    });

    // Tooltip al pasar el mouse
    marker.addListener("mouseover", () => {
      const info = `
        <strong>${item.name || ""}</strong><br>
        Área: ${item.area || "?"} m²<br>
        Precio: ${item.ticket || "?"}<br>
        Portafolio: ${item.portfolio || ""}
      `;
      infoWindow.setContent(info);
      infoWindow.open(map, marker);
    });

    marker.addListener("mouseout", () => {
      infoWindow.close();
    });

    // Eliminar al hacer clic
    marker.addListener("click", () => {
      if (!confirm(`Delete "${item.name}" from Portfolio?`)) return;
      marker.setMap(null); // quitar del mapa

      // Quitar del array y actualizar localStorage
      portfolio.splice(index, 1);
      localStorage.setItem("portfolioData", JSON.stringify(portfolio));
      console.log(`Property "${item.Nombre}" removed.`);
    });
  });
}



// Arrays globales para luego poder limpiar si se desea
let excelMarkers = [];
let excelPolygons = [];

function renderAll(markers = [], polygons = []) {
  // Limpia anteriores si hay
  excelMarkers.forEach(m => m.setMap(null));
  excelPolygons.forEach(p => p.setMap(null));
  excelMarkers = [];
  excelPolygons = [];

  // MARKERS
  markers.forEach(marker => {
    const m = new google.maps.Marker({
      position: marker.position,
      map,
      title: marker.name,
      icon: {
        url: marker.icon?.url || "https://maps.google.com/mapfiles/ms/icons/red-dot.png",
        scaledSize: new google.maps.Size(
          marker.icon?.scaledSize?.width || 30,
          marker.icon?.scaledSize?.height || 30
        )
      }
    });
    excelMarkers.push(m);

    // Opcional: Tooltip al pasar el mouse
    m.addListener("mouseover", () => {
      const info = `<strong>${marker.name}</strong>`;
      infoWindow.setContent(info);
      infoWindow.open(map, m);
    });

    m.addListener("mouseout", () => {
      infoWindow.close();
    });

    // Eliminar al hacer clic
    m.addListener("click", () => {
      if (!confirm(`¿Eliminar el marker "${marker.name}"?`)) return;

      // 1. Quitar del mapa
      m.setMap(null);

      // 2. Quitar del array de markers visuales
      excelMarkers.splice(excelMarkers.indexOf(m), 1);

      // 3. Quitar del array de datos originales
      const i = markers.indexOf(marker);
      if (i !== -1) markers.splice(i, 1);

      // 4. Actualizar localStorage
      const currentData = JSON.parse(localStorage.getItem("excelData") || "{}");
      currentData.markers = markers;
      localStorage.setItem("excelData", JSON.stringify(currentData));

      console.log(`Marker "${marker.name}" eliminado.`);
    });
  });

// POLYGONS
polygons.forEach(polygonData => {
  const { name, paths } = polygonData;

  const polygon = new google.maps.Polygon({
    paths,
    map,
    strokeColor: "#FF6600",
    strokeOpacity: 0.8,
    strokeWeight: 2,
    fillColor: "#FFA500",
    fillOpacity: 0.2
  });

  // 1) Mostrar tooltip al pasar el mouse
  applyPolygonTooltip(polygon, name);

  // 2) Agregar al array visual
  excelPolygons.push(polygon);

  // 3) Agregar evento de clic para eliminar
  polygon.addListener("click", () => {
    if (!confirm(`¿Eliminar el polígono "${name}"?`)) return;

    // Quitar del mapa
    polygon.setMap(null);

    // Quitar del array visual
    const i = excelPolygons.indexOf(polygon);
    if (i !== -1) excelPolygons.splice(i, 1);

    // Quitar del array de datos originales
    const currentData = JSON.parse(localStorage.getItem("excelData") || "{}");
    if (Array.isArray(currentData.polygons)) {
      const idx = currentData.polygons.findIndex(p => p.name === name);
      if (idx !== -1) {
        currentData.polygons.splice(idx, 1);
        localStorage.setItem("excelData", JSON.stringify(currentData));
        console.log(`Polígono "${name}" eliminado.`);
      }
    }
  });
});
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

x








</script>

</script>

</body>

</html>
